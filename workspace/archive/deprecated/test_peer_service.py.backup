#!/usr/bin/env python3
"""
Peer Service セキュリティ機能付きテストスクリプト

Protocol v1.0対応:
- Ed25519署名によるメッセージ認証（必須）
- リプレイ攻撃防止（タイムスタンプ+ノンス）
- 公開鍵レジストリによるピア管理
- Capability exchange（機能交換）
- Task delegation（タスク委譲）
- Heartbeat（死活監視）
- Peer statistics（統計情報）

TODO v1.1:
- X25519/AES-256-GCM payload encryption
- Session management with UUID
- Sequence numbers for ordering
- Chunked message transfer
"""

import asyncio
import sys
import os
import time
import secrets
from datetime import datetime, timezone, timedelta

# servicesディレクトリをパスに追加
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# インポート（複数パターン対応）
try:
    # パターン1: パッケージとして実行
    from services.peer_service import init_service, create_server, PeerService
    from services.crypto import WalletManager
except ImportError:
    # パターン2: スクリプトとして直接実行
    from peer_service import init_service, create_server, PeerService
    from crypto import WalletManager


def setup_test_keys():
    """テスト用の鍵ペアを生成して環境変数に設定"""
    # エンティティAの鍵
    priv_a_hex, pub_a_hex = generate_entity_keypair()
    # エンティティBの鍵
    priv_b_hex, pub_b_hex = generate_entity_keypair()
    return priv_a_hex, pub_a_hex, priv_b_hex, pub_b_hex


async def test_signature_verification():
    """Ed25519署名検証のテスト"""
    print("\n=== Ed25519 Signature Test ===\n")
    
    priv_a_hex, pub_a_hex, priv_b_hex, pub_b_hex = setup_test_keys()
    
    # 環境変数に設定
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a_hex
    
    service_a = init_service("entity-a", 8001, private_key_hex=priv_a_hex)
    
    # テストメッセージ
    payload = {"type": "test", "data": "hello", "from": "entity-a"}
    
    # 署名作成
    signature = service_a.crypto_manager.sign_message(payload)
    print(f"Signature created: {signature[:40]}...")
    
    # 検証用に別のCryptoManagerを作成
    crypto_b = CryptoManager("entity-b", private_key_hex=priv_b_hex)
    
    # 署名検証
    is_valid = crypto_b.verify_signature(
        payload, 
        signature, 
        service_a.crypto_manager.get_ed25519_public_key_b64()
    )
    print(f"Signature valid: {is_valid}")
    assert is_valid, "Signature should be valid"
    
    # 改竄テスト
    tampered_payload = {"type": "test", "data": "tampered", "from": "entity-a"}
    is_invalid = crypto_b.verify_signature(
        tampered_payload,
        signature,
        service_a.crypto_manager.get_ed25519_public_key_b64()
    )
    print(f"Tampered signature invalid: {not is_invalid}")
    assert not is_invalid, "Tampered message should fail verification"
    
    print("\n✅ Signature tests completed")


async def test_encryption():
    """X25519 + AES-256-GCM暗号化のテスト"""
    print("\n=== X25519 + AES-256-GCM Encryption Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    
    crypto_a = CryptoManager("entity-a", private_key_hex=priv_a)
    crypto_b = CryptoManager("entity-b", private_key_hex=priv_b)
    
    # X25519鍵ペアを生成
    crypto_a.generate_x25519_keypair()
    crypto_b.generate_x25519_keypair()
    
    pub_key_b_x25519 = crypto_b.get_x25519_public_key_b64()
    pub_key_a_x25519 = crypto_a.get_x25519_public_key_b64()
    
    # 暗号化
    payload = {"secret": "sensitive data", "value": 12345}
    ciphertext, nonce = crypto_a.encrypt_payload(payload, pub_key_b_x25519, "entity-b")
    print(f"Encrypted payload: {ciphertext[:40]}...")
    print(f"Nonce: {nonce[:20]}...")
    
    # 共有鍵をB側でも導出（通常はハンドシェイクで行う）
    crypto_b.derive_shared_key(pub_key_a_x25519, "entity-a")
    
    # 復号
    decrypted = crypto_b.decrypt_payload(ciphertext, nonce, "entity-a")
    print(f"Decrypted payload: {decrypted}")
    
    assert decrypted == payload, "Decrypted payload should match original"
    print("\n✅ Encryption tests completed")


async def test_jwt_authentication():
    """JWT認証のテスト"""
    print("\n=== JWT Authentication Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    
    crypto_a = CryptoManager("entity-a", private_key_hex=priv_a)
    crypto_b = CryptoManager("entity-b", private_key_hex=priv_b)
    
    # JWTトークン作成
    token = crypto_a.create_jwt_token(audience="entity-b")
    print(f"JWT created: {token[:50]}...")
    
    # JWT検証
    decoded = crypto_b.verify_jwt_token(
        token,
        crypto_a.get_ed25519_public_key_b64(),
        audience="entity-b"
    )
    print(f"JWT valid: {decoded is not None}")
    assert decoded is not None, "JWT should be valid"
    assert decoded["sub"] == "entity-a", "Subject should be entity-a"
    assert decoded["aud"] == "entity-b", "Audience should be entity-b"
    
    # 期限切れテスト（手動で期限切れトークンを作成）
    import jwt as pyjwt
    
    expired_payload = {
        "sub": "entity-a",
        "iat": datetime.now(timezone.utc) - timedelta(minutes=10),
        "exp": datetime.now(timezone.utc) - timedelta(minutes=5),
        "iss": "peer-service",
    }
    
    from cryptography.hazmat.primitives import serialization
    private_key_pem = crypto_a._ed25519_private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )
    expired_token = pyjwt.encode(expired_payload, private_key_pem, algorithm="EdDSA")
    
    expired_decoded = crypto_b.verify_jwt_token(
        expired_token,
        crypto_a.get_ed25519_public_key_b64(),
        audience="entity-b"
    )
    print(f"Expired JWT invalid: {expired_decoded is None}")
    assert expired_decoded is None, "Expired JWT should be invalid"
    
    print("\n✅ JWT tests completed")


async def test_replay_protection():
    """リプレイ攻撃防止のテスト"""
    print("\n=== Replay Protection Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    
    crypto = CryptoManager("test-entity", private_key_hex=priv_a)
    
    # 正常なnonce
    nonce1 = crypto.generate_nonce()
    ts = time.time()
    
    result1 = crypto.check_and_record_nonce(nonce1, ts)
    print(f"First nonce check: {result1}")
    assert result1, "First nonce should be valid"
    
    # 同じnonceのリプレイ
    result2 = crypto.check_and_record_nonce(nonce1, ts)
    print(f"Replay check (should fail): {not result2}")
    assert not result2, "Replay should be detected"
    
    # 古いタイムスタンプ（60秒以上過去）
    old_ts = ts - 120
    old_nonce = crypto.generate_nonce()
    result3 = crypto.check_and_record_nonce(old_nonce, old_ts)
    print(f"Old timestamp check (should fail): {not result3}")
    assert not result3, "Old timestamp should be rejected"
    
    # 未来のタイムスタンプ（60秒以上未来）
    future_ts = ts + 120
    future_nonce = crypto.generate_nonce()
    result4 = crypto.check_and_record_nonce(future_nonce, future_ts)
    print(f"Future timestamp check (should fail): {not result4}")
    assert not result4, "Future timestamp should be rejected"
    
    print("\n✅ Replay protection tests completed")


async def test_secure_message():
    """セキュアメッセージ（統合機能）のテスト"""
    print("\n=== Secure Message Integration Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    
    crypto_a = CryptoManager("entity-a", private_key_hex=priv_a)
    crypto_b = CryptoManager("entity-b", private_key_hex=priv_b)
    
    # X25519鍵ペア生成
    crypto_a.generate_x25519_keypair()
    crypto_b.generate_x25519_keypair()
    
    # 共有鍵導出
    crypto_a.derive_shared_key(crypto_b.get_x25519_public_key_b64(), "entity-b")
    crypto_b.derive_shared_key(crypto_a.get_x25519_public_key_b64(), "entity-a")
    
    # セキュアメッセージ作成（暗号化 + JWT）
    payload = {
        "from": "entity-a",
        "type": "task_delegate",
        "payload": {"task": "important_job", "params": {"key": "value"}}
    }
    
    secure_msg = crypto_a.create_secure_message(
        payload=payload,
        encrypt=True,
        peer_public_key_b64=crypto_b.get_x25519_public_key_b64(),
        peer_id="entity-b",
        include_jwt=True,
        jwt_audience="entity-b"
    )
    
    print(f"Secure message created")
    print(f"  - Timestamp: {secure_msg.timestamp}")
    print(f"  - Nonce: {secure_msg.nonce[:20]}...")
    print(f"  - Signature: {secure_msg.signature[:40]}...")
    print(f"  - Encrypted: {secure_msg.encrypted_payload is not None}")
    print(f"  - JWT: {secure_msg.jwt_token is not None}")
    
    # メッセージ検証・復号
    decrypted = crypto_b.verify_and_decrypt_message(
        secure_msg,
        peer_id="entity-a",
        verify_jwt=True,
        jwt_audience="entity-b"
    )
    
    assert decrypted is not None, "Message should be verified and decrypted"
    assert decrypted["type"] == "task_delegate"
    print(f"\nDecrypted payload: {decrypted}")
    
    print("\n✅ Secure message tests completed")


async def test_peer_service_integration():
    """PeerServiceとの統合テスト"""
    print("\n=== PeerService Integration Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    
    # 環境変数設定
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a
    
    # サービスAを初期化
    service_a = init_service(
        "entity-a", 
        8001,
        private_key_hex=priv_a,
        enable_encryption=True,
        require_signatures=True,
    )
    
    # 公開鍵を取得
    keys_a = service_a.get_public_keys()
    print(f"Entity A public keys: ed25519={keys_a['ed25519'][:20]}..., x25519={keys_a['x25519'][:20]}...")
    
    # ピアBを登録（公開鍵付き）
    service_a.add_peer(
        "entity-b",
        "http://localhost:8002",
        public_key=pub_b,  # Base64ではなくhexなので注意 - 実際はBase64が必要
        x25519_public_key=None,  # ハンドシェイクで取得
    )
    
    # ヘルスチェック
    health = await service_a.health_check()
    print(f"\nHealth check: {health}")
    assert health["security"]["encryption_enabled"]
    assert health["security"]["signatures_required"]
    
    print("\n✅ PeerService integration tests completed")


async def test_full_communication_secure():
    """完全なセキュア双方向通信テスト"""
    print("\n=== Full Secure Communication Test ===\n")
    
    try:
        import aiohttp
        from aiohttp import web
    except ImportError:
        print("⚠️ aiohttp not installed, skipping full communication test")
        return
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    
    # 受信サーバー（セキュアメッセージを処理）
    received_messages = []
    
    async def message_handler(request):
        msg_dict = await request.json()
        received_messages.append(msg_dict)
        
        # 簡易検証（実際はCryptoManagerを使う）
        secure_msg = SecureMessage.from_dict(msg_dict)
        
        return web.json_response({
            "status": "received",
            "verified": secure_msg.signature is not None
        })
    
    app = web.Application()
    app.router.add_post("/message", message_handler)
    
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "localhost", 9997)
    await site.start()
    
    try:
        # 送信側サービス
        os.environ["ENTITY_PRIVATE_KEY"] = priv_a
        service = init_service("test-sender", 8005, private_key_hex=priv_a)
        
        # X25519鍵を生成
        service.crypto_manager.generate_x25519_keypair()
        
        service.add_peer("test-receiver", "http://localhost:9997")
        
        # セキュアメッセージ送信
        result = await service.send_message(
            "test-receiver",
            "status_report",
            {"task_id": "secure-123", "result": "encrypted"},
            encrypt=False,  # テスト用サーバーが復号に対応していないため
            include_jwt=False,
        )
        
        print(f"Send result: {result}")
        print(f"Messages received: {len(received_messages)}")
        
        if received_messages:
            msg = received_messages[0]
            print(f"Received message structure:")
            print(f"  - payload: {msg.get('payload', {}).keys()}")
            print(f"  - signature: {msg.get('signature', '')[:30]}...")
            print(f"  - nonce: {msg.get('nonce', '')[:20]}...")
        
        assert result == True, "Message should be sent successfully"
        assert len(received_messages) == 1, "Message should be received"
        
        print("\n✅ Full secure communication test completed")
        
    finally:
        await runner.cleanup()


async def test_send_with_retry():
    """_send_with_retryメソッドのテスト"""
    print("\n=== _send_with_retry Test ===\n")
    
    try:
        import aiohttp
        from aiohttp import web
    except ImportError:
        print("⚠️ aiohttp not installed, skipping _send_with_retry test")
        return
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a
    
    # テスト用カウンター
    request_count = {"success": 0, "failure": 0}
    
    async def success_handler(request):
        request_count["success"] += 1
        return web.json_response({"status": "ok"})
    
    async def failure_handler(request):
        request_count["failure"] += 1
        return web.json_response({"status": "error"}, status=500)
    
    # テストサーバー
    app = web.Application()
    app.router.add_post("/success", success_handler)
    app.router.add_post("/failure", failure_handler)
    
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "localhost", 9996)
    await site.start()
    
    try:
        service = init_service("test-sender", 8007, private_key_hex=priv_a)
        
        # 成功ケース
        success, status = await service._send_with_retry(
            "http://localhost:9996/success",
            {"test": "data"},
            max_retries=2,
            base_delay=0.1
        )
        print(f"Success case: success={success}, status={status}")
        assert success is True, "Success case should return True"
        assert status == 200, "Success case should return 200"
        
        # サーバーエラー（リトライ対象）
        request_count["failure"] = 0
        success, status = await service._send_with_retry(
            "http://localhost:9996/failure",
            {"test": "data"},
            max_retries=2,
            base_delay=0.1
        )
        print(f"Failure case: success={success}, status={status}, retries={request_count['failure']}")
        assert success is False, "Failure case should return False"
        assert status == 500, "Failure case should return 500"
        assert request_count["failure"] == 2, "Should retry specified times"
        
        # 接続エラー（タイムアウト）
        success, status = await service._send_with_retry(
            "http://localhost:59999/nonexistent",
            {"test": "data"},
            max_retries=1,
            base_delay=0.1
        )
        print(f"Connection error case: success={success}, status={status}")
        assert success is False, "Connection error should return False"
        assert status is None, "Connection error should return None status"
        
        print("\n✅ _send_with_retry tests completed")
        
    finally:
        await runner.cleanup()


async def test_send_with_retry_non_retryable():
    """リトライ対象外のステータスコードテスト"""
    print("\n=== Non-retryable Status Codes Test ===\n")
    
    try:
        import aiohttp
        from aiohttp import web
    except ImportError:
        print("⚠️ aiohttp not installed, skipping test")
        return
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a
    
    request_count = {"count": 0}
    
    async def not_found_handler(request):
        request_count["count"] += 1
        return web.json_response({"status": "not found"}, status=404)
    
    async def forbidden_handler(request):
        request_count["count"] += 1
        return web.json_response({"status": "forbidden"}, status=403)
    
    app = web.Application()
    app.router.add_post("/notfound", not_found_handler)
    app.router.add_post("/forbidden", forbidden_handler)
    
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "localhost", 9995)
    await site.start()
    
    try:
        service = init_service("test-sender", 8008, private_key_hex=priv_a)
        
        # 404 - リトライ対象外
        request_count["count"] = 0
        success, status = await service._send_with_retry(
            "http://localhost:9995/notfound",
            {"test": "data"},
            max_retries=3,
            base_delay=0.1
        )
        print(f"404 case: success={success}, status={status}, attempts={request_count['count']}")
        assert success is False, "404 should return False"
        assert status == 404, "404 should return status 404"
        assert request_count["count"] == 1, "404 should not retry"
        
        # 403 - リトライ対象外
        request_count["count"] = 0
        success, status = await service._send_with_retry(
            "http://localhost:9995/forbidden",
            {"test": "data"},
            max_retries=3,
            base_delay=0.1
        )
        print(f"403 case: success={success}, status={status}, attempts={request_count['count']}")
        assert success is False, "403 should return False"
        assert status == 403, "403 should return status 403"
        assert request_count["count"] == 1, "403 should not retry"
        
        print("\n✅ Non-retryable status codes tests completed")
        
    finally:
        await runner.cleanup()


async def test_backward_compatibility():
    """後方互換性テスト（旧形式メッセージ）"""
    print("\n=== Backward Compatibility Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a
    
    # 署名なしで初期化
    service = init_service(
        "compat-test",
        8006,
        private_key_hex=priv_a,
        require_signatures=False,
        enable_encryption=False,
    )
    
    # 旧形式メッセージ（署名なし）を処理
    old_style_message = {
        "from": "legacy-peer",
        "type": "status",
        "payload": {"status": "ok"},
        "timestamp": "2024-01-01T00:00:00"
    }
    
    # このテストは現在の実装では動作しない（署名必須のため）
    # 将来的に互換モードを追加する場合のテスト
    print("⚠️ Backward compatibility mode not yet implemented")
    print("Current implementation requires signatures for all messages")
    
    print("\n✅ Backward compatibility test completed (skipped)")


# ============ PeerService 機能テスト ============

async def test_peer_service_init():
    """PeerService初期化テスト"""
    print("\n=== PeerService Initialization Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a
    
    # 基本初期化
    service = PeerService("test-entity", 8001)
    assert service.entity_id == "test-entity"
    assert service.port == 8001
    assert len(service.peers) == 0
    assert len(service.message_handlers) >= 5  # デフォルトハンドラ
    print(f"✓ Basic initialization: entity_id={service.entity_id}")
    
    # 暗号機能の初期化確認
    assert service.key_pair is not None
    assert service.signer is not None
    assert service.verifier is not None
    assert service.replay_protector is not None
    print(f"✓ Crypto initialized: public_key={service.get_public_key_hex()[:20]}...")
    
    # キュー・ハートビート初期化確認
    assert service._queue is not None
    assert service._heartbeat is not None
    print("✓ Queue and heartbeat initialized")
    
    # 設定オプションテスト
    service_no_queue = PeerService("test-entity-2", 8002, enable_queue=False)
    assert service_no_queue._queue is None
    print("✓ Queue disabled option works")
    
    service_no_heartbeat = PeerService("test-entity-3", 8003, enable_heartbeat=False)
    assert service_no_heartbeat._heartbeat is None
    print("✓ Heartbeat disabled option works")
    
    print("\n✅ PeerService initialization tests completed")


async def test_peer_management():
    """ピア登録・削除テスト"""
    print("\n=== Peer Management Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a
    
    service = PeerService("test-entity", 8001)
    
    # ピア追加
    service.add_peer("peer-b", "http://localhost:8002", public_key_hex=pub_b)
    assert "peer-b" in service.peers
    assert service.peers["peer-b"] == "http://localhost:8002"
    assert "peer-b" in service.peer_infos
    print("✓ Peer added successfully")
    
    # 統計情報初期化確認
    assert "peer-b" in service.peer_stats
    stats = service.peer_stats["peer-b"]
    assert stats.entity_id == "peer-b"
    assert stats.address == "http://localhost:8002"
    print("✓ Peer stats initialized")
    
    # ハートビート登録確認
    if service._heartbeat:
        status = service._heartbeat.get_status("peer-b")
        assert status is not None
        print("✓ Peer registered for heartbeat")
    
    # ピアリスト取得
    peers = service.list_peers()
    assert "peer-b" in peers
    assert len(peers) == 1
    print("✓ Peer list retrieval works")
    
    # ピアアドレス取得
    address = service.get_peer_address("peer-b")
    assert address == "http://localhost:8002"
    print("✓ Peer address retrieval works")
    
    # 存在しないピア
    assert service.get_peer_address("unknown") is None
    print("✓ Unknown peer returns None")
    
    # ピア削除
    result = service.remove_peer("peer-b")
    assert result is True
    assert "peer-b" not in service.peers
    assert "peer-b" not in service.peer_infos
    print("✓ Peer removed successfully")
    
    # 存在しないピア削除
    result = service.remove_peer("peer-b")
    assert result is False
    print("✓ Removing unknown peer returns False")
    
    # 複数ピア管理
    service.add_peer("peer-1", "http://localhost:8001", pub_a)
    service.add_peer("peer-2", "http://localhost:8002", pub_b)
    assert len(service.peers) == 2
    print("✓ Multiple peer management works")
    
    print("\n✅ Peer management tests completed")


async def test_message_handlers():
    """メッセージハンドラテスト"""
    print("\n=== Message Handlers Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a
    
    service = PeerService("test-entity", 8001)
    
    # デフォルトハンドラ確認
    assert "ping" in service.message_handlers
    assert "status" in service.message_handlers
    assert "heartbeat" in service.message_handlers
    assert "capability_query" in service.message_handlers
    assert "task_delegate" in service.message_handlers
    print("✓ Default handlers registered")
    
    # カスタムハンドラ登録
    test_messages = []
    
    async def custom_handler(message):
        test_messages.append(message)
    
    service.register_handler("custom_type", custom_handler)
    assert "custom_type" in service.message_handlers
    print("✓ Custom handler registered")
    
    # ハンドラ呼び出しテスト（直接）
    test_msg = {"type": "custom_type", "from": "test", "payload": {"data": "test"}}
    await service.message_handlers["custom_type"](test_msg)
    assert len(test_messages) == 1
    print("✓ Custom handler invocation works")
    
    # 統計更新確認（pingハンドラ経由）
    service.add_peer("peer-test", "http://localhost:8001")
    ping_msg = {"type": "ping", "from": "peer-test", "payload": {}}
    
    initial_received = service.peer_stats["peer-test"].total_messages_received
    await service.message_handlers["ping"](ping_msg)
    assert service.peer_stats["peer-test"].total_messages_received == initial_received + 1
    print("✓ Handler updates peer stats")
    
    print("\n✅ Message handlers tests completed")


async def test_handle_message():
    """受信メッセージ処理テスト"""
    print("\n=== Handle Message Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a
    
    service_a = PeerService("entity-a", 8001)
    
    # ピアBの公開鍵を登録
    service_a.add_peer_public_key("entity-b", pub_b)
    
    # セキュアメッセージ作成（BからAへ）
    from crypto_utils import CryptoManager
    crypto_b = CryptoManager("entity-b", private_key_hex=priv_b)
    
    payload = {"status": "ok", "data": "test"}
    secure_msg = crypto_b.create_secure_message(
        payload=payload,
        encrypt=False,
        peer_public_key_b64=None,
        peer_id="entity-a",
        include_jwt=False
    )
    message_dict = secure_msg.to_dict(include_signature=True)
    
    # メッセージ処理（署名検証有効）
    result = await service_a.handle_message(message_dict)
    assert result["status"] == "success"
    print("✓ Secure message processed successfully")
    
    # リプレイ攻撃テスト（同じメッセージを再度送信）
    result = await service_a.handle_message(message_dict)
    assert result["status"] == "error"
    assert "Replay" in result["reason"] or "replay" in result["reason"].lower()
    print("✓ Replay attack detected and rejected")
    
    # レガシー形式メッセージ（署名なし）
    legacy_msg = {
        "from": "legacy-peer",
        "type": "status",
        "payload": {"status": "legacy"},
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    result = await service_a.handle_message(legacy_msg)
    # 署名検証が有効な場合はエラー
    if service_a.enable_verification:
        assert result["status"] == "error"
        print("✓ Legacy unsigned message rejected when verification enabled")
    
    # 不明なメッセージ形式
    unknown_msg = {"unknown": "format"}
    result = await service_a.handle_message(unknown_msg)
    assert result["status"] == "error"
    print("✓ Unknown message format rejected")
    
    # バージョンチェック
    bad_version_msg = {
        "version": "9.9",
        "msg_type": "test",
        "sender_id": "test",
        "payload": {},
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "nonce": secrets.token_hex(16)
    }
    result = await service_a.handle_message(bad_version_msg)
    assert result["status"] == "error"
    assert "version" in result["reason"].lower()
    print("✓ Unsupported version rejected")
    
    print("\n✅ Handle message tests completed")


async def test_health_check():
    """ヘルスチェック機能テスト"""
    print("\n=== Health Check Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a
    
    service = PeerService("test-entity", 8001)
    
    # 基本ヘルスチェック
    health = await service.health_check()
    assert health["entity_id"] == "test-entity"
    assert health["port"] == 8001
    assert health["status"] == "healthy"
    assert health["crypto_available"] is True
    assert health["signing_enabled"] is True
    assert health["verification_enabled"] is True
    assert "public_key" in health
    assert "timestamp" in health
    print("✓ Health check returns correct structure")
    
    # ピア情報
    assert health["peers"] == 0
    assert health["healthy_peers"] == 0
    print("✓ Health check shows correct peer counts")
    
    # ピア追加後
    service.add_peer("peer-1", "http://localhost:8001")
    service.peer_stats["peer-1"].is_healthy = True
    
    health = await service.health_check()
    assert health["peers"] == 1
    assert health["healthy_peers"] == 1
    print("✓ Health check reflects peer status changes")
    
    # ピア統計取得
    stats = service.get_peer_stats()
    assert "peer-1" in stats
    assert stats["peer-1"]["entity_id"] == "peer-1"
    print("✓ Peer stats retrieval works")
    
    # 特定ピア統計
    peer_stats = service.get_peer_stats("peer-1")
    assert peer_stats["entity_id"] == "peer-1"
    
    # 存在しないピア
    assert service.get_peer_stats("unknown") == {}
    print("✓ Stats for unknown peer returns empty dict")
    
    print("\n✅ Health check tests completed")


async def test_queue_and_heartbeat():
    """MessageQueueとHeartbeatManagerテスト"""
    print("\n=== Queue and Heartbeat Test ===\n")
    
    from peer_service import MessageQueue, HeartbeatManager, PeerStatus
    
    # MessageQueueテスト
    queue = MessageQueue(max_retries=3)
    assert queue.get_queue_size() == 0
    print("✓ Queue initialized empty")
    
    # メッセージ追加
    await queue.enqueue("peer-1", "test_type", {"data": "test"})
    assert queue.get_queue_size() == 1
    print("✓ Message enqueued")
    
    stats = queue.get_stats()
    assert stats["queued"] == 1
    assert stats["sent"] == 0
    print("✓ Queue stats correct")
    
    # HeartbeatManagerテスト
    heartbeat = HeartbeatManager(interval_sec=1.0, failure_threshold=2)
    assert heartbeat.get_status("unknown") == PeerStatus.UNKNOWN
    print("✓ Heartbeat manager initialized")
    
    heartbeat.register_peer("peer-1")
    assert heartbeat.get_status("peer-1") == PeerStatus.UNKNOWN
    print("✓ Peer registered for heartbeat")
    
    # 健全ピアリスト（ping実行前は空）
    healthy = heartbeat.get_healthy_peers()
    assert len(healthy) == 0
    print("✓ No healthy peers before ping")
    
    heartbeat.unregister_peer("peer-1")
    assert "peer-1" not in heartbeat.get_all_status()
    print("✓ Peer unregistered from heartbeat")
    
    print("\n✅ Queue and heartbeat tests completed")


async def test_chunked_message():
    """Chunked message transferテスト (v1.1)"""
    print("\n=== Chunked Message Transfer Test ===\n")
    
    from peer_service import ChunkInfo
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a
    
    # ChunkInfoテスト
    chunk_info = ChunkInfo(chunk_id="test-msg-123", total_chunks=3)
    assert chunk_info.chunk_id == "test-msg-123"
    assert chunk_info.total_chunks == 3
    assert not chunk_info.is_complete()
    print("✓ ChunkInfo initialized")
    
    # チャンク追加（add_chunkメソッドを使用）
    chunk_info.add_chunk(0, '{"original_msg_type": "test", "data": {"part": 1')
    chunk_info.add_chunk(1, ', "part": 2, "part": 3')
    assert not chunk_info.is_complete()
    print("✓ Partial chunks not complete")
    
    # 最後のチャンク追加
    chunk_info.add_chunk(2, ', "part": 4}}')
    assert chunk_info.is_complete()
    print("✓ All chunks complete")
    
    # ペイロード再構築
    payload = chunk_info.get_payload()
    assert payload is not None
    assert payload["original_msg_type"] == "test"
    print("✓ Payload reconstructed successfully")
    
    # PeerServiceでのchunkハンドラ確認
    service = PeerService("test-entity", 8001)
    assert "chunk" in service.message_handlers
    print("✓ Chunk handler registered")
    
    # チャンクメッセージ処理テスト
    test_messages = []
    
    async def test_handler(message):
        test_messages.append(message)
    
    service.register_handler("large_data", test_handler)
    
    # チャンクメッセージをシミュレート
    message_id = "chunk-test-001"
    total = 2
    
    # 1つ目のチャンク
    chunk1 = {
        "sender_id": "peer-b",
        "msg_type": "chunk",
        "payload": {
            "message_id": message_id,
            "chunk_index": 0,
            "total_chunks": total,
            "data": 'eyJvcmlnaW5hbF9tc2dfdHlwZSI6ICJsYXJnZV9kYXRhIiwgImRhdGEiOiB7ImtleSI6',
            "is_last": False
        },
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    
    await service.message_handlers["chunk"](chunk1)
    assert message_id in service._chunk_buffer
    assert not service._chunk_buffer[message_id].is_complete()
    print("✓ First chunk processed")
    
    # 2つ目のチャンク（最後）
    chunk2 = {
        "sender_id": "peer-b",
        "msg_type": "chunk",
        "payload": {
            "message_id": message_id,
            "chunk_index": 1,
            "total_chunks": total,
            "data": 'InZhbHVlMSJ9fQ==',
            "is_last": True
        },
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    
    await service.message_handlers["chunk"](chunk2)
    # 再構築後、バッファから削除される
    assert message_id not in service._chunk_buffer
    print("✓ Second chunk processed and message reconstructed")
    
    # cleanup_old_chunksテスト
    old_chunk = ChunkInfo(chunk_id="old-msg", total_chunks=2)
    # 古い時間を設定
    old_chunk.created_at = datetime.now(timezone.utc) - timedelta(hours=2)
    service._chunk_buffer["old-msg"] = old_chunk
    
    cleaned = await service.cleanup_old_chunks(max_age_seconds=3600)
    assert cleaned == 1
    assert "old-msg" not in service._chunk_buffer
    print("✓ Old chunks cleaned up")
    
    print("\n✅ Chunked message tests completed")


async def test_auto_chunking():
    """自動チャンク分割機能のテスト"""
    print("\n=== Auto Chunking Test ===\n")
    
    priv_a, pub_a, priv_b, pub_b = setup_test_keys()
    os.environ["ENTITY_PRIVATE_KEY"] = priv_a
    
    # 送信側サービス
    service_a = PeerService("entity-a", 8001)
    
    # 受信側サービス（chunk受信用）
    priv_b, pub_b = generate_entity_keypair()
    os.environ["ENTITY_PRIVATE_KEY"] = priv_b
    service_b = PeerService("entity-b", 8002)
    
    # ピア登録（実際のHTTP通信はしないためモック）
    service_a.register_peer("entity-b", "http://localhost:8002")
    service_b.register_peer("entity-a", "http://localhost:8001")
    
    # 公開鍵交換
    service_a.add_peer_public_key("entity-b", pub_b)
    service_b.add_peer_public_key("entity-a", pub_a)
    
    # 大きなペイロードを作成（自動分割閾値を超える）
    large_payload = {
        "large_data": "x" * 10000,  # 10KBのデータ
        "metadata": {"type": "test", "size": "large"}
    }
    
    # ペイロードサイズを確認
    payload_size = len(__import__('json').dumps(large_payload).encode('utf-8'))
    print(f"Payload size: {payload_size} bytes")
    print(f"Auto-chunk threshold: {service_a.AUTO_CHUNK_THRESHOLD} bytes")
    assert payload_size > service_a.AUTO_CHUNK_THRESHOLD, "Payload should exceed threshold"
    
    # 自動チャンク分割の判定テスト（実際にはHTTP通信しない）
    # send_chunked_messageが呼ばれることを確認
    original_send_chunked = service_a.send_chunked_message
    chunked_called = [False]
    
    async def mock_send_chunked(*args, **kwargs):
        chunked_called[0] = True
        print("✓ Auto-chunking triggered: send_chunked_message called")
        return True
    
    service_a.send_chunked_message = mock_send_chunked
    
    # auto_chunk=True（デフォルト）で送信
    result = await service_a.send_message(
        target_id="entity-b",
        message_type="large_data",
        payload=large_payload,
        auto_chunk=True
    )
    
    assert chunked_called[0], "Auto-chunking should be triggered"
    print("✓ Auto-chunking works with default settings")
    
    # auto_chunk=Falseでは通常送信が試行される
    chunked_called[0] = False
    result = await service_a.send_message(
        target_id="entity-b",
        message_type="large_data",
        payload=large_payload,
        auto_chunk=False
    )
    
    # 通常送信は失敗する（HTTPサーバーがないため）が、chunkedは呼ばれない
    assert not chunked_called[0], "Auto-chunking should be disabled"
    print("✓ Auto-chunking can be disabled")
    
    # chunkタイプのメッセージは自動分割されない
    chunked_called[0] = False
    result = await service_a.send_message(
        target_id="entity-b",
        message_type="chunk",  # chunkタイプ
        payload=large_payload,
        auto_chunk=True
    )
    
    assert not chunked_called[0], "Chunk messages should not be auto-chunked"
    print("✓ Chunk messages are not recursively chunked")
    
    # 閾値以下のペイロードは分割されない
    small_payload = {"small": "data"}
    chunked_called[0] = False
    result = await service_a.send_message(
        target_id="entity-b",
        message_type="small_data",
        payload=small_payload,
        auto_chunk=True
    )
    
    assert not chunked_called[0], "Small payloads should not be chunked"
    print("✓ Small payloads are not chunked")
    
    # 元のメソッドを復元
    service_a.send_chunked_message = original_send_chunked
    
    print("\n✅ Auto chunking tests completed")


async def main():
    """全テスト実行"""
    print("=" * 60)
    print("Peer Service Security Test Suite v0.3")
    print("=" * 60)
    
    # 暗号化・署名関連のテスト
    await test_signature_verification()
    await test_encryption()
    await test_jwt_authentication()
    await test_replay_protection()
    await test_secure_message()
    
    # 統合テスト
    await test_peer_service_integration()
    await test_full_communication_secure()
    
    # 互換性テスト
    await test_backward_compatibility()
    
    # PeerService機能テスト（新規追加）
    await test_peer_service_init()
    await test_peer_management()
    await test_message_handlers()
    await test_handle_message()
    await test_health_check()
    await test_queue_and_heartbeat()
    
    # Chunk機能テスト
    await test_chunked_message()
    await test_auto_chunking()
    
    print("\n" + "=" * 60)
    print("All security tests completed!")
    print("=" * 60)


if __name__ == "__main__":
    asyncio.run(main())
