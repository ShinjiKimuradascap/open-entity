#!/usr/bin/env python3
"""
DHT-based Peer Registry

Implements decentralized peer discovery using Kademlia DHT protocol.
- Peer registration with signed PeerInfo
- Distributed peer lookup
- Bootstrap node support
- Periodic refresh and cleanup

Requirements: kademlia>=2.0.0
"""

import asyncio
import hashlib
import json
import logging
import time
from typing import Dict, List, Optional, Set, Callable, Any
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone

# Kademlia imports
try:
    from kademlia.network import Server
    from kademlia.storage import ForgetfulStorage
    KADEMLIA_AVAILABLE = True
except ImportError:
    KADEMLIA_AVAILABLE = False
    Server = None
    ForgetfulStorage = None

# Crypto imports
try:
    from services.crypto import KeyPair, MessageSigner, SignatureVerifier, VerifyKey
    CRYPTO_AVAILABLE = True
except ImportError:
    try:
        from crypto import KeyPair, MessageSigner, SignatureVerifier, VerifyKey
        CRYPTO_AVAILABLE = True
    except ImportError:
        CRYPTO_AVAILABLE = False

logger = logging.getLogger(__name__)

# Global registry instance
_global_registry: Optional['DHTRegistry'] = None


@dataclass
class PeerInfo:
    """Peer information stored in DHT"""
    peer_id: str
    entity_id: str
    entity_name: str
    endpoint: str
    public_key: str
    capabilities: List[str]
    timestamp: str
    signature: Optional[str] = None
    
    def to_bytes(self) -> bytes:
        """Convert to bytes for signing/verification (excluding signature)"""
        data = {
            "peer_id": self.peer_id,
            "entity_id": self.entity_id,
            "entity_name": self.entity_name,
            "endpoint": self.endpoint,
            "public_key": self.public_key,
            "capabilities": self.capabilities,
            "timestamp": self.timestamp
        }
        return json.dumps(data, sort_keys=True).encode()
    
    def to_dict(self) -> dict:
        """Convert to dictionary"""
        return asdict(self)
    
    def to_json(self) -> str:
        """Serialize to JSON string"""
        return json.dumps(asdict(self))
    
    @classmethod
    def from_dict(cls, data: dict) -> "PeerInfo":
        """Deserialize from dictionary"""
        return cls(**data)
    
    @classmethod
    def from_json(cls, data: str) -> "PeerInfo":
        """Deserialize from JSON string"""
        obj = json.loads(data)
        return cls(**obj)
    
    def is_expired(self, max_age_seconds: int = 3600) -> bool:
        """Check if peer info is expired"""
        try:
            # Parse ISO format timestamp
            dt = datetime.fromisoformat(self.timestamp)
            timestamp = dt.timestamp()
        except (ValueError, TypeError):
            # Fallback to current time if parsing fails
            timestamp = time.time()
        return (time.time() - timestamp) > max_age_seconds
    
    def sign(self, keypair: KeyPair) -> str:
        """Sign this PeerInfo with the given keypair"""
        if not CRYPTO_AVAILABLE:
            raise RuntimeError("Crypto module not available")
        
        signer = MessageSigner(keypair)
        signature = signer.sign(self.to_bytes())
        self.signature = signature
        return signature
    
    def verify(self) -> bool:
        """Verify the signature of this PeerInfo"""
        if not CRYPTO_AVAILABLE or not self.signature:
            return False
        
        try:
            vk = VerifyKey.from_hex(self.public_key)
            verifier = SignatureVerifier(vk)
            return verifier.verify(self.to_bytes(), self.signature)
        except Exception as e:
            logger.error(f"Signature verification failed: {e}")
            return False


class DHTRegistry:
    """
    Kademlia DHT-based peer registry
    
    Provides decentralized peer discovery with:
    - Peer registration (signed PeerInfo)
    - Peer lookup by ID
    - Random peer discovery
    - Bootstrap node support
    """
    
    def __init__(
        self,
        entity_id: str,
        entity_name: str,
        endpoint: str,
        public_key: str,
        capabilities: List[str],
        keypair: Optional[KeyPair] = None,
        bootstrap_nodes: Optional[List[tuple]] = None,
        refresh_interval: int = 600,  # 10 minutes
        max_peer_age: int = 3600,  # 1 hour
        port: int = 8468
    ):
        """
        Initialize DHT Registry
        
        Args:
            entity_id: Local entity identifier
            entity_name: Human-readable entity name
            endpoint: HTTP endpoint URL (e.g., http://localhost:8000)
            public_key: Ed25519 public key hex string
            capabilities: List of capability strings
            keypair: Ed25519 keypair for signing peer info (optional)
            bootstrap_nodes: List of (host, port) tuples
            refresh_interval: Seconds between refresh cycles
            max_peer_age: Maximum age of peer info before considered stale
            port: UDP port for DHT
        """
        self.entity_id = entity_id
        self.entity_name = entity_name
        self.endpoint = endpoint
        self.public_key = public_key
        self.capabilities = capabilities
        self.keypair = keypair
        self.bootstrap_nodes = bootstrap_nodes or []
        self.refresh_interval = refresh_interval
        self.max_peer_age = max_peer_age
        self.port = port
        
        # Generate peer_id from public_key hash
        self.peer_id = hashlib.sha256(public_key.encode()).hexdigest()
        
        # Kademlia server
        self._server: Optional[Server] = None
        self._storage: Optional[ForgetfulStorage] = None
        
        # Local cache
        self._peers: Dict[str, PeerInfo] = {}  # peer_id -> PeerInfo
        self._callbacks: List[Callable[[str, PeerInfo], None]] = []
        
        # Refresh task
        self._refresh_task: Optional[asyncio.Task] = None
        self._running = False
        
        logger.info(f"DHTRegistry initialized for {entity_id} (peer_id: {self.peer_id[:16]}...)")
    
    async def start(self) -> bool:
        """Start DHT server and bootstrap"""
        if not KADEMLIA_AVAILABLE:
            logger.error("kademlia library not installed. Run: pip install kademlia")
            return False
        
        try:
            self._storage = ForgetfulStorage(ttl=self.max_peer_age)
            self._server = Server(storage=self._storage)
            await self._server.listen(self.port)
            
            logger.info(f"DHT server listening on port {self.port}")
            
            # Bootstrap if nodes provided
            if self.bootstrap_nodes:
                await self._server.bootstrap(self.bootstrap_nodes)
                logger.info(f"Bootstrapped with {len(self.bootstrap_nodes)} nodes")
            
            self._running = True
            
            # Start refresh loop
            self._refresh_task = asyncio.create_task(self._refresh_loop())
            
            # Register self
            await self.register_self()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to start DHT server: {e}")
            return False
    
    async def stop(self):
        """Stop DHT server"""
        self._running = False
        
        if self._refresh_task:
            self._refresh_task.cancel()
            try:
                await self._refresh_task
            except asyncio.CancelledError:
                pass
        
        if self._server:
            self._server.stop()
            logger.info("DHT server stopped")
    
    async def _refresh_loop(self):
        """Periodic refresh loop"""
        while self._running:
            try:
                await asyncio.sleep(self.refresh_interval)
                await self._refresh_peers()
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Refresh loop error: {e}")
    
    async def _refresh_peers(self):
        """Refresh peer registrations"""
        # Republish our own info
        await self.register_self()
        
        # Clean up expired peers from local cache
        expired = [
            peer_id for peer_id, info in self._peers.items()
            if info.is_expired(self.max_peer_age)
        ]
        for peer_id in expired:
            del self._peers[peer_id]
            logger.debug(f"Removed expired peer: {peer_id}")
    
    def _create_peer_info(self) -> PeerInfo:
        """Create PeerInfo for self"""
        info = PeerInfo(
            peer_id=self.peer_id,
            entity_id=self.entity_id,
            entity_name=self.entity_name,
            endpoint=self.endpoint,
            public_key=self.public_key,
            capabilities=self.capabilities,
            timestamp=datetime.now(timezone.utc).isoformat()
        )
        
        # Sign the peer info if keypair available
        if self.keypair and CRYPTO_AVAILABLE:
            self._sign_peer_info(info)
        
        return info
    
    def _sign_peer_info(self, info: PeerInfo) -> str:
        """Sign PeerInfo with our keypair"""
        if not self.keypair or not CRYPTO_AVAILABLE:
            raise RuntimeError("Keypair required for signing")
        
        signature = info.sign(self.keypair)
        logger.debug(f"Signed peer info for {info.entity_id}")
        return signature
    
    def _verify_peer_info(self, info: PeerInfo) -> bool:
        """Verify peer info signature"""
        if not CRYPTO_AVAILABLE or not info.signature:
            return False
        
        return info.verify()
    
    async def register_self(self) -> bool:
        """Register own peer info to DHT"""
        if not self._server:
            return False
        
        try:
            info = self._create_peer_info()
            key = f"peer:{self.peer_id}"
            value = info.to_json()
            
            await self._server.set(key, value)
            logger.debug(f"Registered self to DHT: {self.entity_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to register self: {e}")
            return False
    
    async def lookup_peer(self, peer_id: str) -> Optional[PeerInfo]:
        """Lookup peer by ID from DHT"""
        if not self._server:
            return None
        
        try:
            # Check local cache first
            if peer_id in self._peers:
                info = self._peers[peer_id]
                if not info.is_expired(self.max_peer_age):
                    return info
            
            # Query DHT
            key = f"peer:{peer_id}"
            result = await self._server.get(key)
            
            if result:
                info = PeerInfo.from_json(result)
                
                # Verify signature if crypto available
                if CRYPTO_AVAILABLE and info.signature:
                    if not self._verify_peer_info(info):
                        logger.warning(f"Invalid signature for peer: {peer_id}")
                        return None
                
                # Update cache
                self._peers[peer_id] = info
                return info
            
            return None
            
        except Exception as e:
            logger.error(f"Failed to lookup peer {peer_id}: {e}")
            return None
    
    async def discover_peers(self, count: int = 10) -> List[PeerInfo]:
        """Discover random peers by querying random IDs"""
        if not self._server:
            return []
        
        discovered = []
        
        for _ in range(count):
            # Generate random ID
            random_id = hashlib.sha1(str(time.time()).encode()).hexdigest()[:20]
            
            try:
                # Query DHT for peers near this ID
                result = await self._server.get(f"random:{random_id}")
                
                # Get peers from routing table
                if hasattr(self._server, 'protocol') and self._server.protocol:
                    router = self._server.protocol.router
                    if router:
                        # Get all nodes from routing table
                        nodes = []
                        for bucket in router.buckets:
                            nodes.extend(bucket.get_nodes())
                        
                        # Lookup each node's peer info
                        for node in nodes[:count]:
                            peer_id = node.id.hex()
                            info = await self.lookup_peer(peer_id)
                            if info and info not in discovered:
                                discovered.append(info)
                                
            except Exception as e:
                logger.debug(f"Discovery error: {e}")
                continue
        
        return discovered[:count]
    
    def get_all_peers(self) -> Dict[str, PeerInfo]:
        """Get all known peers from local cache"""
        # Remove expired entries
        expired = [
            pid for pid, info in self._peers.items()
            if info.is_expired(self.max_peer_age)
        ]
        for pid in expired:
            del self._peers[pid]
        
        return self._peers.copy()
    
    def on_peer_discovered(self, callback: Callable[[str, PeerInfo], None]):
        """Register callback for peer discovery events"""
        self._callbacks.append(callback)
    
    def _notify_callbacks(self, peer_id: str, info: PeerInfo):
        """Notify all registered callbacks"""
        for callback in self._callbacks:
            try:
                callback(peer_id, info)
            except Exception as e:
                logger.error(f"Peer discovery callback error: {e}")
    
    @property
    def is_running(self) -> bool:
        """Check if DHT is running"""
        return self._running and self._server is not None
    
    def get_stats(self) -> Dict[str, Any]:
        """Get DHT statistics"""
        if not self._server:
            return {
                "status": "not_running",
                "entity_id": self.entity_id,
                "peer_id": self.peer_id,
                "port": self.port,
                "bootstrap_nodes": len(self.bootstrap_nodes),
                "cached_peers": len(self._peers)
            }
        
        total_nodes = 0
        if hasattr(self._server, 'protocol') and self._server.protocol:
            router = self._server.protocol.router
            if router:
                total_nodes = sum(len(b.get_nodes()) for b in router.buckets)
        
        return {
            "status": "running" if self._running else "stopped",
            "entity_id": self.entity_id,
            "peer_id": self.peer_id,
            "port": self.port,
            "known_nodes": total_nodes,
            "cached_peers": len(self._peers),
            "bootstrap_nodes": len(self.bootstrap_nodes)
        }


def create_dht_registry(
    entity_id: str,
    entity_name: str,
    endpoint: str,
    public_key: str,
    capabilities: List[str],
    keypair: Optional[KeyPair] = None,
    bootstrap_nodes: Optional[List[tuple]] = None,
    refresh_interval: int = 600,
    max_peer_age: int = 3600,
    port: int = 8468
) -> DHTRegistry:
    """
    Create a new DHT registry instance
    
    Args:
        entity_id: Entity identifier
        entity_name: Human-readable entity name
        endpoint: HTTP endpoint URL
        public_key: Ed25519 public key hex string
        capabilities: List of capability strings
        keypair: Ed25519 keypair for signing (optional)
        bootstrap_nodes: List of (host, port) tuples
        refresh_interval: Seconds between refresh cycles
        max_peer_age: Maximum age of peer info
        port: UDP port for DHT
    
    Returns:
        DHTRegistry instance
    """
    global _global_registry
    
    _global_registry = DHTRegistry(
        entity_id=entity_id,
        entity_name=entity_name,
        endpoint=endpoint,
        public_key=public_key,
        capabilities=capabilities,
        keypair=keypair,
        bootstrap_nodes=bootstrap_nodes,
        refresh_interval=refresh_interval,
        max_peer_age=max_peer_age,
        port=port
    )
    
    return _global_registry


def get_dht_registry() -> Optional[DHTRegistry]:
    """Get the global DHT registry instance"""
    return _global_registry
