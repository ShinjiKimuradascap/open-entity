#!/usr/bin/env python3
"""
Cryptographic utilities for peer communication - Compatibility Wrapper
Ed25519 signatures and AES-256-GCM encryption

This module is a compatibility wrapper around crypto_utils.py.
All new code should use crypto_utils directly.
"""

from typing import Optional, Dict, Any, Tuple, List
from dataclasses import dataclass
from datetime import datetime, timezone

# Import all from crypto_utils to maintain backward compatibility
CRYPTO_UTILS_AVAILABLE = False
try:
    # Pattern 1: Package import
    from services.crypto_utils import (
        CryptoManager,
        SecureMessage as SecureMessageCU,
        WalletManager,
        generate_entity_keypair,
        TIMESTAMP_TOLERANCE_SECONDS,
        JWT_EXPIRY_MINUTES,
        NONCE_SIZE_BYTES,
        AES_KEY_SIZE_BYTES,
        REPLAY_WINDOW_SECONDS,
    )
    CRYPTO_UTILS_AVAILABLE = True
except ImportError:
    try:
        # Pattern 2: Direct script import
        from crypto_utils import (
            CryptoManager,
            SecureMessage as SecureMessageCU,
            WalletManager,
            generate_entity_keypair,
            TIMESTAMP_TOLERANCE_SECONDS,
            JWT_EXPIRY_MINUTES,
            NONCE_SIZE_BYTES,
            AES_KEY_SIZE_BYTES,
            REPLAY_WINDOW_SECONDS,
        )
        CRYPTO_UTILS_AVAILABLE = True
    except ImportError:
        pass
    # Fallback: define essential classes/functions here if crypto_utils is removed
    TIMESTAMP_TOLERANCE_SECONDS = 60
    JWT_EXPIRY_MINUTES = 5
    NONCE_SIZE_BYTES = 16
    AES_KEY_SIZE_BYTES = 32
    REPLAY_WINDOW_SECONDS = 300
    CryptoManager = None
    SecureMessageCU = None
    WalletManager = None
    generate_entity_keypair = None

# Maintain backward compatibility: generate_keypair is an alias for generate_entity_keypair
generate_keypair = generate_entity_keypair

# Re-export everything for backward compatibility
__all__ = [
    # Classes from crypto_utils
    "CryptoManager",
    "SecureMessage",
    "WalletManager",
    # Classes defined in this module
    "KeyPair",
    "MessageSigner",
    "SignatureVerifier",
    "ReplayProtector",
    # Functions
    "generate_entity_keypair",
    "generate_keypair",  # Backward compatibility alias
    "get_public_key_from_private",
    # Constants
    "TIMESTAMP_TOLERANCE_SECONDS",
    "JWT_EXPIRY_MINUTES",
    "NONCE_SIZE_BYTES",
    "AES_KEY_SIZE_BYTES",
    "REPLAY_WINDOW_SECONDS",
]

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MessageChunk":
        return cls(
            chunk_id=data["chunk_id"],
            session_id=data["session_id"],
            message_id=data["message_id"],
            sequence_num=data["sequence_num"],
            chunk_index=data["chunk_index"],
            total_chunks=data["total_chunks"],
            data=data["data"],
            timestamp=data.get("timestamp")
        )


@dataclass
class ChunkBuffer:
    """Buffer for reassembling chunked messages"""
    message_id: str
    session_id: str
    total_chunks: int
    chunks: Dict[int, str] = None
    received_at: str = None
    
    def __post_init__(self):
        if self.chunks is None:
            self.chunks = {}
        if self.received_at is None:
            self.received_at = datetime.now(timezone.utc).isoformat()
    
    def add_chunk(self, chunk_index: int, data: str) -> bool:
        """Add a chunk to the buffer"""
        if chunk_index in self.chunks:
            return False  # Duplicate
        self.chunks[chunk_index] = data
        return True
    
    def is_complete(self) -> bool:
        """Check if all chunks received"""
        return len(self.chunks) >= self.total_chunks
    
    def assemble(self) -> Optional[str]:
        """Assemble chunks into complete data"""
        if not self.is_complete():
            return None
        sorted_chunks = [self.chunks[i] for i in range(self.total_chunks)]
        return "".join(sorted_chunks)
    
    def get_progress(self) -> Tuple[int, int]:
        """Return (received, total) progress"""
        return (len(self.chunks), self.total_chunks)


class MessageValidator:
    """Message validation for protocol v1.0"""
    
    PROTOCOL_VERSION = "1.0"
    
    @classmethod
    def validate_version(cls, version: str) -> bool:
        """Validate protocol version"""
        return version == cls.PROTOCOL_VERSION
    
    @classmethod
    def validate_session_id(cls, session_id: Optional[str]) -> bool:
        """Validate session ID (UUID v4 format)"""
        if session_id is None:
            return True  # Optional field
        if not session_id:
            return False
        try:
            parsed = uuid.UUID(session_id)
            return parsed.version == 4
        except (ValueError, AttributeError):
            return False
    
    @staticmethod
    def validate_sequence(current: int, expected: int) -> bool:
        """Validate sequence number ordering"""
        return current == expected


class ChunkUtils:
    """Utility functions for message chunking"""
    
    DEFAULT_CHUNK_SIZE = 64000  # 64KB chunks
    
    @classmethod
    def split_message(
        cls,
        message: Dict[str, Any],
        session_id: str,
        sequence_num: int,
        chunk_size: int = DEFAULT_CHUNK_SIZE
    ) -> List[MessageChunk]:
        """
        Split a message into chunks
        
        Args:
            message: The message to split
            session_id: Session ID
            sequence_num: Sequence number
            chunk_size: Maximum chunk size
            
        Returns:
            List of MessageChunk objects
        """
        message_json = json.dumps(message)
        message_bytes = message_json.encode('utf-8')
        encoded = base64.b64encode(message_bytes).decode('utf-8')
        
        total_chunks = (len(encoded) + chunk_size - 1) // chunk_size
        chunks = []
        message_id = str(uuid.uuid4())
        
        for i in range(total_chunks):
            start = i * chunk_size
            end = min(start + chunk_size, len(encoded))
            chunk_data = encoded[start:end]
            
            chunk = MessageChunk(
                chunk_id=f"{message_id}_{i}",
                session_id=session_id,
                message_id=message_id,
                sequence_num=sequence_num,
                chunk_index=i,
                total_chunks=total_chunks,
                data=chunk_data
            )
            chunks.append(chunk)
        
        return chunks
    
    @classmethod
    def reassemble_message(cls, chunks: List[MessageChunk]) -> Optional[Dict[str, Any]]:
        """
        Reassemble chunks into a message
        
        Args:
            chunks: List of chunks (must be complete)
            
        Returns:
            Reassembled message dict or None if incomplete
        """
        if not chunks:
            return None
        
        total = chunks[0].total_chunks
        if len(chunks) < total:
            return None
        
        # Sort by chunk index
        sorted_chunks = sorted(chunks, key=lambda c: c.chunk_index)
        encoded = "".join(c.data for c in sorted_chunks)
        
        try:
            decoded = base64.b64decode(encoded)
            return json.loads(decoded.decode('utf-8'))
        except Exception:
            return None
    
    @classmethod
    def estimate_chunks(cls, message: Dict[str, Any], chunk_size: int = DEFAULT_CHUNK_SIZE) -> int:
        """Estimate number of chunks needed for a message"""
        message_json = json.dumps(message)
        message_bytes = message_json.encode('utf-8')
        encoded_len = (len(message_bytes) + 2) // 3 * 4  # Base64 expands by ~4/3
        return (encoded_len + chunk_size - 1) // chunk_size


@dataclass
class KeyPair:
    """Ed25519 key pair"""
    private_key: bytes
    public_key: bytes
    
    @classmethod
    def generate(cls) -> "KeyPair":
        """Generate new key pair"""
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        signing_key = SigningKey.generate()
        # Use expanded 64-byte private key format (seed + public key scalar)
        expanded_private_key = signing_key._signing_key
        return cls(
            private_key=bytes(expanded_private_key),
            public_key=bytes(signing_key.verify_key)
        )
    
    @classmethod
    def from_private_key(cls, private_key: bytes) -> "KeyPair":
        """Create key pair from private key (32-byte seed or 64-byte expanded)"""
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        # Extract seed (first 32 bytes) if 64-byte expanded key is provided
        seed = private_key[:32] if len(private_key) == 64 else private_key
        signing_key = SigningKey(seed)
        # Always store as expanded 64-byte format
        expanded_private_key = signing_key._signing_key
        return cls(
            private_key=bytes(expanded_private_key),
            public_key=bytes(signing_key.verify_key)
        )
    
    @classmethod
    def from_private_key_hex(cls, private_key_hex: str) -> "KeyPair":
        """Create key pair from hex-encoded private key"""
        return cls.from_private_key(bytes.fromhex(private_key_hex))
    
    def get_public_key_hex(self) -> str:
        """Get hex-encoded public key"""
        return self.public_key.hex()
    
    def get_private_key_hex(self) -> str:
        """Get hex-encoded private key"""
        return self.private_key.hex()
    
    def save_to_file(
        self, 
        filepath: str, 
        password: Optional[str] = None,
        entity_id: Optional[str] = None
    ) -> bool:
        """
        Save key pair to encrypted file
        
        Args:
            filepath: Path to save the key file
            password: Optional password for encryption (if None, stored unencrypted)
            entity_id: Optional entity ID to include in metadata
            
        Returns:
            True if saved successfully, False otherwise
        """
        try:
            # Build key data
            key_data = {
                "version": 1,
                "algorithm": "Ed25519",
                "public_key": self.get_public_key_hex(),
                "created_at": __import__('datetime').datetime.now(__import__('datetime').timezone.utc).isoformat(),
            }
            
            if entity_id:
                key_data["entity_id"] = entity_id
            
            # Encrypt private key if password provided
            if password:
                import secrets
                from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
                from cryptography.hazmat.primitives.ciphers.aead import AESGCM
                from cryptography.hazmat.primitives import hashes
                
                # Generate salt and nonce
                salt = secrets.token_bytes(32)
                nonce = secrets.token_bytes(12)
                
                # Derive encryption key
                kdf = PBKDF2HMAC(
                    algorithm=hashes.SHA256(),
                    length=32,
                    salt=salt,
                    iterations=600000,
                )
                encryption_key = kdf.derive(password.encode("utf-8"))
                
                # Encrypt private key
                aesgcm = AESGCM(encryption_key)
                ciphertext = aesgcm.encrypt(nonce, self.private_key, None)
                
                key_data["encrypted"] = True
                key_data["encrypted_private_key"] = base64.b64encode(ciphertext).decode("ascii")
                key_data["salt"] = base64.b64encode(salt).decode("ascii")
                key_data["nonce"] = base64.b64encode(nonce).decode("ascii")
                key_data["kdf"] = "PBKDF2-SHA256"
                key_data["kdf_iterations"] = 600000
            else:
                # Store unencrypted (not recommended for production)
                key_data["encrypted"] = False
                key_data["private_key"] = self.get_private_key_hex()
            
            # Ensure directory exists
            import os
            dir_path = os.path.dirname(filepath)
            if dir_path and not os.path.exists(dir_path):
                os.makedirs(dir_path, mode=0o700)
            
            # Write file
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(key_data, f, indent=2)
            
            # Set file permissions (owner only)
            os.chmod(filepath, 0o600)
            
            return True
            
        except Exception as e:
            print(f"Failed to save key pair: {e}")
            return False
    
    @classmethod
    def load_from_file(
        cls, 
        filepath: str, 
        password: Optional[str] = None
    ) -> Optional["KeyPair"]:
        """
        Load key pair from file
        
        Args:
            filepath: Path to the key file
            password: Password for decryption (if file is encrypted)
            
        Returns:
            KeyPair instance or None if loading failed
        """
        try:
            with open(filepath, "r", encoding="utf-8") as f:
                key_data = json.load(f)
            
            # Check version
            version = key_data.get("version", 1)
            if version != 1:
                raise ValueError(f"Unsupported key file version: {version}")
            
            # Get private key
            if key_data.get("encrypted", False):
                if not password:
                    raise ValueError("Password required for encrypted key file")
                
                from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
                from cryptography.hazmat.primitives.ciphers.aead import AESGCM
                from cryptography.hazmat.primitives import hashes
                
                # Decode encrypted data
                ciphertext = base64.b64decode(key_data["encrypted_private_key"])
                salt = base64.b64decode(key_data["salt"])
                nonce = base64.b64decode(key_data["nonce"])
                
                # Derive encryption key
                iterations = key_data.get("kdf_iterations", 600000)
                kdf = PBKDF2HMAC(
                    algorithm=hashes.SHA256(),
                    length=32,
                    salt=salt,
                    iterations=iterations,
                )
                encryption_key = kdf.derive(password.encode("utf-8"))
                
                # Decrypt private key
                aesgcm = AESGCM(encryption_key)
                private_key = aesgcm.decrypt(nonce, ciphertext, None)
                
            else:
                # Unencrypted
                private_key_hex = key_data["private_key"]
                private_key = bytes.fromhex(private_key_hex)
            
            return cls.from_private_key(private_key)
            
        except Exception as e:
            print(f"Failed to load key pair: {e}")
            return None


class MessageSigner:
    """Ed25519 message signer"""
    
    def __init__(self, key_pair: KeyPair):
        self.key_pair = key_pair
        # SigningKey only accepts 32-byte seed, so extract seed from expanded key
        seed = key_pair.private_key[:32] if len(key_pair.private_key) == 64 else key_pair.private_key
        self._signing_key = SigningKey(seed) if NACL_AVAILABLE else None
    
    def sign_message(self, message: Dict[str, Any]) -> str:
        """
        Sign a message dictionary
        
        Args:
            message: Message to sign (must be JSON-serializable)
            
        Returns:
            Base64-encoded signature
        """
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        
        # Create canonical JSON representation
        message_bytes = self._canonical_json(message)
        
        # Sign
        signed = self._signing_key.sign(message_bytes)
        signature = signed.signature
        
        return base64.b64encode(signature).decode('utf-8')
    
    def sign_bytes(self, data: bytes) -> str:
        """
        Sign raw bytes
        
        Args:
            data: Data to sign
            
        Returns:
            Hex-encoded signature (protocol v1.0)
        """
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        
        signed = self._signing_key.sign(data)
        return signed.signature.hex()
    
    @staticmethod
    def _canonical_json(data: Dict[str, Any]) -> bytes:
        """Create canonical JSON representation for signing"""
        # Sort keys for deterministic encoding
        return json.dumps(data, sort_keys=True, separators=(',', ':')).encode('utf-8')


class SignatureVerifier:
    """Ed25519 signature verifier"""
    
    def __init__(self, public_keys: Dict[str, bytes] = None):
        """
        Initialize verifier with known public keys
        
        Args:
            public_keys: Dict mapping entity_id to public key bytes
        """
        self.public_keys = public_keys or {}
        self._verify_keys: Dict[str, VerifyKey] = {}
        if NACL_AVAILABLE:
            for entity_id, key_bytes in self.public_keys.items():
                self._verify_keys[entity_id] = VerifyKey(key_bytes)
    
    def add_public_key(self, entity_id: str, public_key: bytes) -> None:
        """Add a public key for an entity"""
        self.public_keys[entity_id] = public_key
        if NACL_AVAILABLE:
            self._verify_keys[entity_id] = VerifyKey(public_key)
    
    def add_public_key_hex(self, entity_id: str, public_key_hex: str) -> None:
        """Add a hex-encoded public key for an entity"""
        self.add_public_key(entity_id, bytes.fromhex(public_key_hex))
    
    def remove_public_key(self, entity_id: str) -> bool:
        """Remove a public key for an entity
        
        Args:
            entity_id: ID of the entity whose key should be removed
            
        Returns:
            True if key was removed, False if entity_id not found
        """
        if entity_id in self.public_keys:
            del self.public_keys[entity_id]
            if entity_id in self._verify_keys:
                del self._verify_keys[entity_id]
            return True
        return False
    
    def verify_message(self, message: Dict[str, Any], signature: str, sender_id: str) -> bool:
        """
        Verify a message signature
        
        Args:
            message: Message dictionary
            signature: Base64-encoded signature
            sender_id: ID of the sender (to lookup public key)
            
        Returns:
            True if signature is valid
        """
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        
        if sender_id not in self._verify_keys:
            raise ValueError(f"Unknown sender: {sender_id}")
        
        verify_key = self._verify_keys[sender_id]
        message_bytes = MessageSigner._canonical_json(message)
        signature_bytes = base64.b64decode(signature)
        
        try:
            verify_key.verify(message_bytes, signature_bytes)
            return True
        except BadSignatureError:
            return False
    
    def verify_bytes(self, data: bytes, signature: str, sender_id: str) -> bool:
        """
        Verify raw bytes signature
        
        Args:
            data: Data that was signed
            signature: Hex-encoded signature (protocol v1.0)
            sender_id: ID of the sender
            
        Returns:
            True if signature is valid
        """
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        
        if sender_id not in self._verify_keys:
            raise ValueError(f"Unknown sender: {sender_id}")
        
        verify_key = self._verify_keys[sender_id]
        signature_bytes = bytes.fromhex(signature)
        
        try:
            verify_key.verify(data, signature_bytes)
            return True
        except BadSignatureError:
            return False


class SecureMessage:
    """Secure message with signature (protocol v1.0)
    
    Payload format: {encrypted: bool, data: base64}
    """
    
    def __init__(
        self,
        version: str,
        msg_type: str,
        sender_id: str,
        payload: Dict[str, Any],
        timestamp: Optional[str] = None,
        nonce: Optional[str] = None,
        signature: Optional[str] = None,
        session_id: Optional[str] = None,
        sequence_num: Optional[int] = None,
        recipient_id: Optional[str] = None
    ):
        self.version = version
        self.msg_type = msg_type
        self.sender_id = sender_id
        # Ensure payload follows v1.0 format: {encrypted: bool, data: base64}
        if isinstance(payload, dict) and "encrypted" in payload and "data" in payload:
            self.payload = payload
        else:
            # Wrap raw payload in v1.0 format (unencrypted)
            self.payload = {
                "encrypted": False,
                "data": base64.b64encode(json.dumps(payload, sort_keys=True).encode()).decode()
            }
        self.timestamp = timestamp or datetime.now(timezone.utc).isoformat()
        self.nonce = nonce or self._generate_nonce()
        self.signature = signature
        self.session_id = session_id
        self.sequence_num = sequence_num
        self.recipient_id = recipient_id
    
    @staticmethod
    def _generate_nonce() -> str:
        """Generate 128-bit nonce as hex string"""
        return secrets.token_hex(16)
    
    def get_payload_data(self) -> Dict[str, Any]:
        """Extract and decode the payload data"""
        data_b64 = self.payload.get("data", "")
        data_bytes = base64.b64decode(data_b64)
        return json.loads(data_bytes.decode())
    
    def to_dict(self, include_signature: bool = True) -> Dict[str, Any]:
        """Convert to dictionary (protocol v1.0 format)"""
        data = {
            "version": self.version,
            "msg_type": self.msg_type,
            "sender_id": self.sender_id,
            "recipient_id": self.recipient_id,
            "session_id": self.session_id,
            "sequence_num": self.sequence_num,
            "payload": self.payload,
            "timestamp": self.timestamp,
            "nonce": self.nonce
        }
        if include_signature and self.signature:
            data["signature"] = self.signature
        return data
    
    def get_signable_data(self) -> Dict[str, Any]:
        """Get data to be signed (excluding signature field)"""
        return self._get_signable_data_from_fields(
            self.version, self.msg_type, self.sender_id, self.recipient_id,
            self.session_id, self.sequence_num, self.payload,
            self.timestamp, self.nonce
        )
    
    @staticmethod
    def _get_signable_data_from_fields(
        version: str,
        msg_type: str,
        sender_id: str,
        recipient_id: Optional[str],
        session_id: Optional[str],
        sequence_num: Optional[int],
        payload: Dict[str, Any],
        timestamp: str,
        nonce: str
    ) -> Dict[str, Any]:
        """Get signable data from individual fields (static helper)
        
        This static method avoids duplication when creating signable data
        from both SecureMessage objects and raw dictionaries.
        """
        data = {
            "version": version,
            "msg_type": msg_type,
            "sender_id": sender_id,
            "payload": payload,
            "timestamp": timestamp,
            "nonce": nonce
        }
        if recipient_id:
            data["recipient_id"] = recipient_id
        if session_id:
            data["session_id"] = session_id
        if sequence_num is not None:
            data["sequence_num"] = sequence_num
        return data
    
    def sign(self, signer: MessageSigner) -> None:
        """Sign this message"""
        self.signature = signer.sign_message(self.get_signable_data())
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SecureMessage":
        """Create from dictionary"""
        return cls(
            version=data["version"],
            msg_type=data["msg_type"],
            sender_id=data["sender_id"],
            payload=data["payload"],
            timestamp=data.get("timestamp"),
            nonce=data.get("nonce"),
            signature=data.get("signature"),
            session_id=data.get("session_id"),
            sequence_num=data.get("sequence_num"),
            recipient_id=data.get("recipient_id")
        )


class EncryptedMessage:
    """
    X25519-based encrypted message
    Uses ECDH key exchange + AES-256-GCM for encryption
    """
    
    def __init__(
        self,
        sender_id: str,
        recipient_id: str,
        ciphertext: bytes,
        nonce: bytes,
        ephemeral_public_key: bytes,
        timestamp: Optional[str] = None
    ):
        self.sender_id = sender_id
        self.recipient_id = recipient_id
        self.ciphertext = ciphertext
        self.nonce = nonce
        self.ephemeral_public_key = ephemeral_public_key
        self.timestamp = timestamp or datetime.now(timezone.utc).isoformat()
    
    @classmethod
    def encrypt(
        cls,
        sender_keypair: KeyPair,
        recipient_public_key: bytes,
        sender_id: str,
        recipient_id: str,
        plaintext: Dict[str, Any]
    ) -> "EncryptedMessage":
        """
        Encrypt a message for a recipient
        
        Args:
            sender_keypair: Sender's X25519 keypair (reuses Ed25519 key as X25519)
            recipient_public_key: Recipient's X25519 public key
            sender_id: Sender entity ID
            recipient_id: Recipient entity ID
            plaintext: Message payload to encrypt
            
        Returns:
            EncryptedMessage instance
        """
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        
        # Convert Ed25519 keys to X25519 for encryption
        # Note: Ed25519 keys can be converted to X25519 for use with ECDH
        from nacl.signing import SigningKey
        from nacl.public import PrivateKey, PublicKey, Box
        
        # Generate ephemeral X25519 keypair for this session
        ephemeral_private = PrivateKey.generate()
        ephemeral_public = ephemeral_private.public_key
        
        # Convert Ed25519 private key to X25519 for ECDH
        sender_seed = sender_keypair.private_key[:32] if len(sender_keypair.private_key) == 64 else sender_keypair.private_key
        sender_x25519_private = crypto_sign_ed25519_sk_to_curve25519(sender_seed)
        sender_x25519 = PrivateKey(sender_x25519_private)
        
        # Convert Ed25519 public key to X25519 for ECDH
        recipient_x25519_public = crypto_sign_ed25519_pk_to_curve25519(recipient_public_key)
        recipient_x25519 = PublicKey(recipient_x25519_public)
        
        # Perform ECDH key exchange
        box = Box(ephemeral_private, recipient_x25519)
        
        # Encrypt the plaintext
        plaintext_bytes = json.dumps(plaintext, sort_keys=True).encode('utf-8')
        encrypted = box.encrypt(plaintext_bytes)
        
        # Split nonce and ciphertext
        nonce = encrypted[:Box.NONCE_SIZE]
        ciphertext = encrypted[Box.NONCE_SIZE:]
        
        return cls(
            sender_id=sender_id,
            recipient_id=recipient_id,
            ciphertext=ciphertext,
            nonce=nonce,
            ephemeral_public_key=bytes(ephemeral_public),
            timestamp=datetime.now(timezone.utc).isoformat()
        )
    
    def decrypt(self, recipient_private_key: bytes) -> Dict[str, Any]:
        """
        Decrypt the message
        
        Args:
            recipient_private_key: Recipient's X25519 private key
            
        Returns:
            Decrypted plaintext as dict
        """
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        
        from nacl.public import PrivateKey, PublicKey, Box
        
        # Convert Ed25519 private key to X25519 for decryption
        # This is required because the recipient's key is stored as Ed25519
        recipient_seed = recipient_private_key[:32] if len(recipient_private_key) == 64 else recipient_private_key
        recipient_x25519_private = crypto_sign_ed25519_sk_to_curve25519(recipient_seed)
        recipient_x25519 = PrivateKey(recipient_x25519_private)
        ephemeral_public = PublicKey(self.ephemeral_public_key)
        
        # Perform ECDH key exchange
        box = Box(recipient_x25519, ephemeral_public)
        
        # Combine nonce and ciphertext for decryption
        encrypted = self.nonce + self.ciphertext
        
        # Decrypt
        plaintext = box.decrypt(encrypted)
        
        return json.loads(plaintext.decode('utf-8'))
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary (base64-encoded binary fields)"""
        return {
            "version": "0.4.0",
            "msg_type": "encrypted",
            "sender_id": self.sender_id,
            "recipient_id": self.recipient_id,
            "ciphertext": base64.b64encode(self.ciphertext).decode('utf-8'),
            "nonce": base64.b64encode(self.nonce).decode('utf-8'),
            "ephemeral_public_key": base64.b64encode(self.ephemeral_public_key).decode('utf-8'),
            "timestamp": self.timestamp
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "EncryptedMessage":
        """Create from dictionary"""
        return cls(
            sender_id=data["sender_id"],
            recipient_id=data["recipient_id"],
            ciphertext=base64.b64decode(data["ciphertext"]),
            nonce=base64.b64decode(data["nonce"]),
            ephemeral_public_key=base64.b64decode(data["ephemeral_public_key"]),
            timestamp=data.get("timestamp")
        )
    
    def sign(self, signer: MessageSigner) -> str:
        """Sign the encrypted message with unified fields"""
        signable_data = {
            "version": "0.4.0",
            "msg_type": "encrypted",
            "sender_id": self.sender_id,
            "recipient_id": self.recipient_id,
            "ciphertext": base64.b64encode(self.ciphertext).decode('utf-8'),
            "nonce": base64.b64encode(self.nonce).decode('utf-8'),
            "ephemeral_public_key": base64.b64encode(self.ephemeral_public_key).decode('utf-8'),
            "timestamp": self.timestamp
        }
        return signer.sign_message(signable_data)


class HandshakeChallenge:
    """
    Secure handshake challenge-response protocol
    Used for peer authentication during initial connection
    """
    
    def __init__(self, challenger_id: str, challenge: bytes, timestamp: str):
        self.challenger_id = challenger_id
        self.challenge = challenge
        self.timestamp = timestamp
    
    @classmethod
    def generate(cls, challenger_id: str) -> "HandshakeChallenge":
        """Generate a new challenge"""
        challenge = secrets.token_bytes(32)
        timestamp = datetime.now(timezone.utc).isoformat()
        return cls(challenger_id, challenge, timestamp)
    
    def create_response(
        self,
        responder_id: str,
        responder_keypair: KeyPair
    ) -> Dict[str, Any]:
        """
        Create a response to this challenge
        
        Args:
            responder_id: Responding entity ID
            responder_keypair: Responder's keypair for signing
            
        Returns:
            Challenge response dictionary
        """
        signer = MessageSigner(responder_keypair)
        
        response_data = {
            "challenge": base64.b64encode(self.challenge).decode('utf-8'),
            "responder_id": responder_id,
            "challenger_id": self.challenger_id,
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        
        signature = signer.sign_message(response_data)
        
        response_data["signature"] = signature
        response_data["responder_public_key"] = responder_keypair.get_public_key_hex()
        
        return response_data
    
    def verify_response(
        self,
        response: Dict[str, Any],
        verifier: SignatureVerifier
    ) -> Tuple[bool, Optional[str]]:
        """
        Verify a challenge response
        
        Args:
            response: Response dictionary from create_response
            verifier: SignatureVerifier with responder's public key
            
        Returns:
            (is_valid, error_message)
        """
        # Check challenge matches
        response_challenge = base64.b64decode(response.get("challenge", ""))
        if response_challenge != self.challenge:
            return False, "Challenge mismatch"
        
        # Check challenger matches
        if response.get("challenger_id") != self.challenger_id:
            return False, "Challenger ID mismatch"
        
        # Add responder's public key to verifier if provided
        responder_public_key = response.get("responder_public_key")
        responder_id = response.get("responder_id")
        
        if responder_public_key and responder_id:
            if responder_id not in verifier.public_keys:
                verifier.add_public_key_hex(responder_id, responder_public_key)
        
        # Verify signature
        signature = response.get("signature")
        if not signature:
            return False, "Missing signature"
        
        # Reconstruct signed data
        signed_data = {
            "challenge": response["challenge"],
            "responder_id": response["responder_id"],
            "challenger_id": response["challenger_id"],
            "timestamp": response["timestamp"]
        }
        
        try:
            is_valid = verifier.verify_message(signed_data, signature, responder_id)
            return is_valid, None if is_valid else "Invalid signature"
        except ValueError as e:
            return False, f"Verification error: {e}"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "challenger_id": self.challenger_id,
            "challenge": base64.b64encode(self.challenge).decode('utf-8'),
            "timestamp": self.timestamp
        }


class ReplayProtector:
    """Replay attack protection using nonce and timestamp"""
    
    def __init__(self, max_age_seconds: int = 60, cleanup_interval: int = 300):
        """
        Initialize replay protector
        
        Args:
            max_age_seconds: Maximum age of valid messages (default 60)
            cleanup_interval: Seconds between nonce cache cleanups
        """
        self.max_age_seconds = max_age_seconds
        self.cleanup_interval = cleanup_interval
        self._seen_nonces: Dict[str, datetime] = {}
        self._last_cleanup = datetime.now(timezone.utc)
    
    def is_valid(self, nonce: str, timestamp_str: str) -> Tuple[bool, Optional[str]]:
        """
        Check if message is valid (not replayed and within time window)
        
        Args:
            nonce: Message nonce
            timestamp_str: ISO format timestamp
            
        Returns:
            (is_valid, error_message)
        """
        # Parse timestamp
        try:
            timestamp = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
        except ValueError:
            return False, "Invalid timestamp format"
        
        # Check timestamp is within acceptable window
        now = datetime.now(timezone.utc)
        age = (now - timestamp).total_seconds()
        
        if abs(age) > self.max_age_seconds:
            return False, f"Message too old or future timestamp (age: {age}s)"
        
        # Check for replay
        if nonce in self._seen_nonces:
            return False, "Nonce already seen (possible replay attack)"
        
        # Record nonce
        self._seen_nonces[nonce] = now
        
        # Periodic cleanup
        self._cleanup_if_needed()
        
        return True, None
    
    def _cleanup_if_needed(self) -> None:
        """Remove old nonces if cleanup interval has passed"""
        now = datetime.now(timezone.utc)
        if (now - self._last_cleanup).total_seconds() > self.cleanup_interval:
            cutoff = now.timestamp() - self.max_age_seconds
            self._seen_nonces = {
                nonce: ts for nonce, ts in self._seen_nonces.items()
                if ts.timestamp() > cutoff
            }
            self._last_cleanup = now


# Payload helper functions for protocol v1.0
def encrypt_payload(plaintext: Dict[str, Any], encryption_key: bytes) -> Dict[str, Any]:
    """
    Create encrypted payload for protocol v1.0
    
    Args:
        plaintext: Data to encrypt
        encryption_key: 32-byte encryption key
        
    Returns:
        Payload dict with encrypted=true and base64-encoded data
    """
    if not NACL_AVAILABLE:
        raise RuntimeError("PyNaCl not installed")
    
    from nacl.secret import SecretBox
    
    box = SecretBox(encryption_key)
    plaintext_bytes = json.dumps(plaintext, sort_keys=True).encode('utf-8')
    encrypted = box.encrypt(plaintext_bytes)
    
    # Split nonce and ciphertext
    nonce = encrypted[:SecretBox.NONCE_SIZE]
    ciphertext = encrypted[SecretBox.NONCE_SIZE:]
    
    return {
        "encrypted": True,
        "data": base64.b64encode(nonce + ciphertext).decode('utf-8')
    }


def decrypt_payload(payload: Dict[str, Any], encryption_key: bytes) -> Dict[str, Any]:
    """
    Decrypt payload for protocol v1.0
    
    Args:
        payload: Payload dict with encrypted=true and base64-encoded data
        encryption_key: 32-byte encryption key
        
    Returns:
        Decrypted data dict
        
    Raises:
        ProtocolError: If decryption fails
    """
    if not NACL_AVAILABLE:
        raise RuntimeError("PyNaCl not installed")
    
    if not payload.get("encrypted", False):
        # Plain payload, return data directly
        data = payload.get("data")
        if isinstance(data, dict):
            return data
        return json.loads(base64.b64decode(data).decode('utf-8'))
    
    from nacl.secret import SecretBox
    
    try:
        box = SecretBox(encryption_key)
        encrypted_data = base64.b64decode(payload["data"])
        decrypted = box.decrypt(encrypted_data)
        return json.loads(decrypted.decode('utf-8'))
    except Exception as e:
        raise ProtocolError(DECRYPTION_FAILED, f"Failed to decrypt payload: {e}")


def create_plain_payload(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create plain (unencrypted) payload for protocol v1.0
    
    Args:
        data: Data to include in payload
        
    Returns:
        Payload dict with encrypted=false
    """
    return {
        "encrypted": False,
        "data": data
    }


def load_key_from_env(env_var: str = "ENTITY_PRIVATE_KEY") -> Optional[KeyPair]:
    """Load key pair from environment variable"""
    private_key_hex = os.environ.get(env_var)
    if not private_key_hex:
        return None
    try:
        return KeyPair.from_private_key_hex(private_key_hex)
    except Exception as e:
        raise ValueError(f"Invalid private key in {env_var}: {e}")


class KeyFingerprint:
    """
    Ed25519 public key fingerprint generator
    Uses SHA256(pubkey)[:16] for 128-bit fingerprint
    """
    
    @staticmethod
    def generate(public_key: bytes) -> str:
        """
        Generate fingerprint from Ed25519 public key
        
        Args:
            public_key: 32-byte Ed25519 public key
            
        Returns:
            32-character hex string (SHA256(pubkey)[:16])
        """
        full_hash = hashlib.sha256(public_key).digest()
        return full_hash[:16].hex()
    
    @staticmethod
    def generate_from_hex(public_key_hex: str) -> str:
        """Generate fingerprint from hex-encoded public key"""
        return KeyFingerprint.generate(bytes.fromhex(public_key_hex))
    
    @staticmethod
    def verify(public_key: bytes, fingerprint: str) -> bool:
        """Verify that a fingerprint matches a public key"""
        return KeyFingerprint.generate(public_key) == fingerprint.lower()


class E2EEncryption:
    """
    End-to-End Encryption using X25519 + HKDF-SHA256 + AES-256-GCM
    
    Properly converts Ed25519 keys to X25519 following libsodium spec:
    - Ed25519 signing keys can be converted to X25519 for key exchange
    - Uses crypto_sign_ed25519_pk_to_curve25519 and crypto_sign_ed25519_sk_to_curve25519
    """
    
    NONCE_SIZE = 12  # 96-bit nonce for AES-GCM
    KEY_SIZE = 32    # 256-bit key
    TAG_SIZE = 16    # 128-bit authentication tag
    
    def __init__(self):
        self._shared_keys: Dict[str, bytes] = {}  # peer_id -> shared_key
    
    @staticmethod
    def ed25519_to_x25519_private(ed25519_private_key: bytes) -> bytes:
        """
        Convert Ed25519 private key to X25519 private key
        Following libsodium crypto_sign_ed25519_sk_to_curve25519
        
        Args:
            ed25519_private_key: 64-byte Ed25519 private key (seed + pubkey) or 32-byte seed
            
        Returns:
            32-byte X25519 private key
        """
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        
        # PyNaCl stores Ed25519 private key as 64 bytes (seed + pubkey)
        # We need the first 32 bytes (seed) for conversion
        if len(ed25519_private_key) == 64:
            seed = ed25519_private_key[:32]
        elif len(ed25519_private_key) == 32:
            seed = ed25519_private_key
        else:
            raise ValueError(f"Invalid Ed25519 private key length: {len(ed25519_private_key)}")
        
        return crypto_sign_ed25519_sk_to_curve25519(seed)
    
    @staticmethod
    def ed25519_to_x25519_public(ed25519_public_key: bytes) -> bytes:
        """
        Convert Ed25519 public key to X25519 public key
        Following libsodium crypto_sign_ed25519_pk_to_curve25519
        
        Args:
            ed25519_public_key: 32-byte Ed25519 public key
            
        Returns:
            32-byte X25519 public key
        """
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        
        if len(ed25519_public_key) != 32:
            raise ValueError(f"Invalid Ed25519 public key length: {len(ed25519_public_key)}")
        
        return crypto_sign_ed25519_pk_to_curve25519(ed25519_public_key)
    
    def derive_shared_key(
        self,
        my_ed25519_private: bytes,
        peer_ed25519_public: bytes,
        peer_id: str,
        context: bytes = b"peer-e2e-v1"
    ) -> bytes:
        """
        Derive shared key using X25519 ECDH + HKDF-SHA256
        
        Args:
            my_ed25519_private: Our Ed25519 private key
            peer_ed25519_public: Peer Ed25519 public key
            peer_id: Peer identifier for caching
            context: HKDF context/info string
            
        Returns:
            32-byte shared key for AES-256-GCM
        """
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        
        if peer_id in self._shared_keys:
            return self._shared_keys[peer_id]
        
        # Convert Ed25519 keys to X25519
        my_x25519_private = self.ed25519_to_x25519_private(my_ed25519_private)
        peer_x25519_public = self.ed25519_to_x25519_public(peer_ed25519_public)
        
        # Perform ECDH
        my_private_key = PrivateKey(my_x25519_private)
        peer_public_key = PublicKey(peer_x25519_public)
        
        box = Box(my_private_key, peer_public_key)
        # Box.shared_key() gives us the raw shared secret
        shared_secret = box.shared_key()
        
        # HKDF-SHA256 key derivation
        shared_key = self._hkdf_derive(shared_secret, context)
        
        self._shared_keys[peer_id] = shared_key
        return shared_key
    
    def _hkdf_derive(self, shared_secret: bytes, context: bytes) -> bytes:
        """
        HKDF-SHA256 key derivation
        
        Args:
            shared_secret: Shared secret from ECDH
            context: Application-specific context
            
        Returns:
            32-byte derived key
        """
        # HKDF-Extract
        salt = b""  # Optional salt (empty for simplicity)
        prk = hashlib.sha256(salt + shared_secret).digest()
        
        # HKDF-Expand (single block, 32 bytes)
        info = context + b"\x01"
        okm = hashlib.sha256(prk + info).digest()
        
        return okm
    
    def encrypt(
        self,
        plaintext: bytes,
        shared_key: bytes,
        associated_data: Optional[bytes] = None
    ) -> Tuple[bytes, bytes]:
        """
        Encrypt using AES-256-GCM
        
        Args:
            plaintext: Data to encrypt
            shared_key: 32-byte encryption key
            associated_data: Optional additional authenticated data
            
        Returns:
            Tuple of (ciphertext_with_tag, nonce)
        """
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        
        # Generate random nonce
        nonce = os.urandom(self.NONCE_SIZE)
        
        # Use SecretBox for XSalsa20-Poly1305 or implement AES-GCM
        # For AES-256-GCM, we'll use the cryptography library if available
        # Otherwise, use PyNaCl's SecretBox (XSalsa20-Poly1305)
        try:
            from cryptography.hazmat.primitives.ciphers.aead import AESGCM
            aesgcm = AESGCM(shared_key)
            ciphertext = aesgcm.encrypt(nonce, plaintext, associated_data)
            return ciphertext, nonce
        except ImportError:
            # Fallback to SecretBox (XSalsa20-Poly1305)
            box = SecretBox(shared_key)
            encrypted = box.encrypt(plaintext, nonce)
            # SecretBox format: nonce (24) + ciphertext + tag (16)
            return encrypted[self.NONCE_SIZE:], encrypted[:self.NONCE_SIZE]
    
    def decrypt(
        self,
        ciphertext: bytes,
        nonce: bytes,
        shared_key: bytes,
        associated_data: Optional[bytes] = None
    ) -> bytes:
        """
        Decrypt using AES-256-GCM
        
        Args:
            ciphertext: Ciphertext with authentication tag
            nonce: Encryption nonce
            shared_key: 32-byte encryption key
            associated_data: Optional additional authenticated data
            
        Returns:
            Decrypted plaintext
        """
        if not NACL_AVAILABLE:
            raise RuntimeError("PyNaCl not installed")
        
        try:
            from cryptography.hazmat.primitives.ciphers.aead import AESGCM
            aesgcm = AESGCM(shared_key)
            return aesgcm.decrypt(nonce, ciphertext, associated_data)
        except ImportError:
            # Fallback to SecretBox
            box = SecretBox(shared_key)
            return box.decrypt(nonce + ciphertext)
    
    def encrypt_message(
        self,
        message: Dict[str, Any],
        my_ed25519_private: bytes,
        peer_ed25519_public: bytes,
        peer_id: str
    ) -> Dict[str, Any]:
        """
        Encrypt a message dictionary using E2E encryption
        
        Args:
            message: Message dictionary to encrypt
            my_ed25519_private: Our Ed25519 private key
            peer_ed25519_public: Peer Ed25519 public key
            peer_id: Peer identifier
            
        Returns:
            Encrypted message structure
        """
        # Derive shared key
        shared_key = self.derive_shared_key(
            my_ed25519_private,
            peer_ed25519_public,
            peer_id
        )
        
        # Serialize and encrypt payload
        plaintext = json.dumps(message, sort_keys=True, separators=(',', ':')).encode('utf-8')
        ciphertext, nonce = self.encrypt(plaintext, shared_key)
        
        return {
            "ciphertext": base64.b64encode(ciphertext).decode('utf-8'),
            "nonce": base64.b64encode(nonce).decode('utf-8'),
            "version": "1.0"
        }
    
    def decrypt_message(
        self,
        encrypted_data: Dict[str, Any],
        my_ed25519_private: bytes,
        peer_ed25519_public: bytes,
        peer_id: str
    ) -> Dict[str, Any]:
        """
        Decrypt an E2E encrypted message
        
        Args:
            encrypted_data: Encrypted message structure
            my_ed25519_private: Our Ed25519 private key
            peer_ed25519_public: Peer Ed25519 public key
            peer_id: Peer identifier
            
        Returns:
            Decrypted message dictionary
        """
        # Derive shared key
        shared_key = self.derive_shared_key(
            my_ed25519_private,
            peer_ed25519_public,
            peer_id
        )
        
        # Decrypt
        ciphertext = base64.b64decode(encrypted_data["ciphertext"])
        nonce = base64.b64decode(encrypted_data["nonce"])
        
        plaintext = self.decrypt(ciphertext, nonce, shared_key)
        
        return json.loads(plaintext.decode('utf-8'))


class SecureMessageV1:
    """
    v1.0 Secure Message Format
    - Adds recipient_id field
    - Supports chunk_info for large message fragmentation
    - Extended header with session support
    """
    
    VERSION = "1.0"
    
    @dataclass
    class ChunkInfo:
        """Chunk information for fragmented messages"""
        chunk_index: int
        total_chunks: int
        message_id: str
        
        def to_dict(self) -> Dict[str, Any]:
            return {
                "chunk_index": self.chunk_index,
                "total_chunks": self.total_chunks,
                "message_id": self.message_id
            }
        
        @classmethod
        def from_dict(cls, data: Dict[str, Any]) -> "SecureMessageV1.ChunkInfo":
            return cls(
                chunk_index=data["chunk_index"],
                total_chunks=data["total_chunks"],
                message_id=data["message_id"]
            )
    
    def __init__(
        self,
        msg_type: str,
        sender_id: str,
        recipient_id: str,
        payload: Dict[str, Any],
        session_id: Optional[str] = None,
        sequence_num: Optional[int] = None,
        timestamp: Optional[str] = None,
        nonce: Optional[str] = None,
        signature: Optional[str] = None,
        chunk_info: Optional[ChunkInfo] = None,
        encrypted: bool = False,
        encryption_header: Optional[Dict[str, Any]] = None
    ):
        self.version = self.VERSION
        self.msg_type = msg_type
        self.sender_id = sender_id
        self.recipient_id = recipient_id
        self.payload = payload
        self.session_id = session_id
        self.sequence_num = sequence_num
        self.timestamp = timestamp or datetime.now(timezone.utc).isoformat()
        self.nonce = nonce or self._generate_nonce()
        self.signature = signature
        self.chunk_info = chunk_info
        self.encrypted = encrypted
        self.encryption_header = encryption_header or {}
    
    @staticmethod
    def _generate_nonce() -> str:
        """Generate 128-bit nonce as hex string"""
        return secrets.token_hex(16)
    
    def to_dict(self, include_signature: bool = True) -> Dict[str, Any]:
        """Convert to dictionary"""
        data = {
            "version": self.version,
            "msg_type": self.msg_type,
            "sender_id": self.sender_id,
            "recipient_id": self.recipient_id,
            "payload": self.payload,
            "timestamp": self.timestamp,
            "nonce": self.nonce,
            "encrypted": self.encrypted
        }
        
        if self.session_id:
            data["session_id"] = self.session_id
        
        if self.sequence_num is not None:
            data["sequence_num"] = self.sequence_num
        
        if include_signature and self.signature:
            data["signature"] = self.signature
        
        if self.chunk_info:
            data["chunk_info"] = self.chunk_info.to_dict()
        
        if self.encryption_header:
            data["encryption_header"] = self.encryption_header
        
        return data
    
    def get_signable_data(self) -> Dict[str, Any]:
        """Get data to be signed (excluding signature field)"""
        data = {
            "version": self.version,
            "msg_type": self.msg_type,
            "sender_id": self.sender_id,
            "recipient_id": self.recipient_id,
            "payload": self.payload,
            "timestamp": self.timestamp,
            "nonce": self.nonce,
            "encrypted": self.encrypted
        }
        
        if self.session_id:
            data["session_id"] = self.session_id
        
        if self.sequence_num is not None:
            data["sequence_num"] = self.sequence_num
        
        if self.chunk_info:
            data["chunk_info"] = self.chunk_info.to_dict()
        
        return data
    
    def sign(self, signer: MessageSigner) -> None:
        """Sign this message"""
        self.signature = signer.sign_message(self.get_signable_data())
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "SecureMessageV1":
        """Create from dictionary"""
        chunk_info = None
        if "chunk_info" in data:
            chunk_info = cls.ChunkInfo.from_dict(data["chunk_info"])
        
        return cls(
            msg_type=data["msg_type"],
            sender_id=data["sender_id"],
            recipient_id=data["recipient_id"],
            payload=data["payload"],
            session_id=data.get("session_id"),
            sequence_num=data.get("sequence_num"),
            timestamp=data.get("timestamp"),
            nonce=data.get("nonce"),
            signature=data.get("signature"),
            chunk_info=chunk_info,
            encrypted=data.get("encrypted", False),
            encryption_header=data.get("encryption_header")
        )
    
    def create_chunk(
        self,
        chunk_index: int,
        total_chunks: int,
        message_id: str,
        chunk_payload: Dict[str, Any]
    ) -> "SecureMessageV1":
        """
        Create a chunked version of this message
        
        Args:
            chunk_index: Index of this chunk (0-based)
            total_chunks: Total number of chunks
            message_id: Unique identifier for the complete message
            chunk_payload: Payload for this specific chunk
            
        Returns:
            New SecureMessageV1 with chunk info
        """
        return SecureMessageV1(
            msg_type=self.msg_type,
            sender_id=self.sender_id,
            recipient_id=self.recipient_id,
            payload=chunk_payload,
            session_id=self.session_id,
            sequence_num=self.sequence_num,
            timestamp=self.timestamp,
            nonce=self._generate_nonce(),  # Fresh nonce for each chunk
            chunk_info=self.ChunkInfo(
                chunk_index=chunk_index,
                total_chunks=total_chunks,
                message_id=message_id
            ),
            encrypted=self.encrypted,
            encryption_header=self.encryption_header
        )
    
    def is_chunk(self) -> bool:
        """Check if this is a chunked message"""
        return self.chunk_info is not None


# Convenience functions for common operations
def generate_keypair() -> KeyPair:
    """Generate a new Ed25519 key pair"""
    return KeyPair.generate()


def generate_entity_keypair() -> Tuple[str, str]:
    """Generate a new Ed25519 key pair for entity authentication
    
    This function provides the same interface as crypto_utils.generate_entity_keypair
    for backward compatibility during crypto module unification.
    
    Returns:
        (private_key_hex, public_key_hex) tuple
    """
    if not NACL_AVAILABLE:
        raise ImportError("PyNaCl is required for key generation")
    
    signing_key = SigningKey.generate()
    private_key_hex = signing_key.encode().hex()
    public_key_hex = signing_key.verify_key.encode().hex()
    return private_key_hex, public_key_hex


def get_public_key_from_private(private_key_hex: str) -> str:
    """Get public key from private key"""
    keypair = KeyPair.from_private_key_hex(private_key_hex)
    return keypair.get_public_key_hex()


if __name__ == "__main__":
    # Test
    if NACL_AVAILABLE:
        print("=" * 60)
        print("Testing Cryptographic Functions")
        print("=" * 60)
        
        # Generate key pairs
        kp_a = generate_keypair()
        kp_b = generate_keypair()
        print("\n1. Key Generation")
        print(f"   Entity A public key: {kp_a.get_public_key_hex()[:32]}...")
        print(f"   Entity B public key: {kp_b.get_public_key_hex()[:32]}...")
        
        # Create signer and verifier
        signer = MessageSigner(kp_a)
        verifier = SignatureVerifier()
        verifier.add_public_key("entity-a", kp_a.public_key)
        
        # Test SecureMessage
        print("\n2. SecureMessage (Ed25519 Signing)")
        message = SecureMessage(
            version="0.3",
            msg_type="test",
            sender_id="entity-a",
            payload={"data": "hello"}
        )
        message.sign(signer)
        print(f"   Signature: {message.signature[:50]}...")
        
        is_valid = verifier.verify_message(
            message.get_signable_data(),
            message.signature,
            "entity-a"
        )
        print(f"   Signature valid: {is_valid}")
        assert is_valid, "Signature verification failed!"
        
        # Test EncryptedMessage
        print("\n3. EncryptedMessage (X25519 + AES-256-GCM)")
        test_data = {"secret": "This is a secret message", "value": 42}
        encrypted = EncryptedMessage.encrypt(
            sender_keypair=kp_a,
            recipient_public_key=kp_b.public_key,
            sender_id="entity-a",
            recipient_id="entity-b",
            plaintext=test_data
        )
        print(f"   Ciphertext length: {len(encrypted.ciphertext)} bytes")
        print(f"   Ephemeral public key: {encrypted.ephemeral_public_key.hex()[:32]}...")
        
        # Decrypt
        decrypted = encrypted.decrypt(kp_b.private_key)
        print(f"   Decrypted data: {decrypted}")
        assert decrypted == test_data, "Decryption mismatch!"
        print("   [PASS] Encryption/Decryption successful")
        
        # Test EncryptedMessage with signature
        print("\n4. EncryptedMessage with Signature")
        signature = encrypted.sign(signer)
        print(f"   Message signature: {signature[:50]}...")
        print("   [PASS] Signed encrypted message")
        
        # Test HandshakeChallenge
        print("\n5. HandshakeChallenge (Mutual Authentication)")
        challenge = HandshakeChallenge.generate("entity-a")
        print(f"   Challenge generated by: {challenge.challenger_id}")
        print(f"   Challenge bytes: {challenge.challenge.hex()[:32]}...")
        
        # Create response
        response = challenge.create_response("entity-b", kp_b)
        print(f"   Response created by: entity-b")
        print(f"   Response signature: {response['signature'][:50]}...")
        
        # Verify response
        verifier_b = SignatureVerifier()
        is_valid, error = challenge.verify_response(response, verifier_b)
        print(f"   Verification result: {is_valid}")
        if error:
            print(f"   Error: {error}")
        assert is_valid, "Challenge response verification failed!"
        print("   [PASS] Handshake challenge-response successful")
        
        # Test ReplayProtector
        print("\n6. ReplayProtector")
        protector = ReplayProtector(max_age_seconds=60)
        nonce = message.nonce
        timestamp = message.timestamp
        valid, error = protector.is_valid(nonce, timestamp)
        print(f"   First check: {valid}")
        assert valid, f"First check failed: {error}"
        
        valid2, error2 = protector.is_valid(nonce, timestamp)
        print(f"   Second check (replay): {valid2} (expected: False)")
        assert not valid2, "Replay detection failed!"
        print("   [PASS] Replay protection working")
        
        print("\n" + "=" * 60)
        print("All cryptographic tests passed!")
        print("=" * 60)
        
        # Test replay protection
        protector = ReplayProtector(max_age_seconds=60)
        valid, error = protector.is_valid(message.nonce, message.timestamp)
        print(f"Replay check: {valid} (error: {error})")
        
        # Should fail on second check
        valid2, error2 = protector.is_valid(message.nonce, message.timestamp)
        print(f"Replay check 2: {valid2} (error: {error2})")
        
        print("\nAll tests passed!")
        
        # Test v1.0 Features
        print("\n" + "=" * 60)
        print("v1.0 Features Test")
        print("=" * 60)
        
        # 7. KeyFingerprint
        print("\n7. KeyFingerprint")
        fp_a = KeyFingerprint.generate(kp_a.public_key)
        fp_b = KeyFingerprint.generate(kp_b.public_key)
        print(f"   Entity A fingerprint: {fp_a}")
        print(f"   Entity B fingerprint: {fp_b}")
        assert len(fp_a) == 32, "Fingerprint must be 32 hex chars (128 bits)"
        assert KeyFingerprint.verify(kp_a.public_key, fp_a), "Fingerprint verification failed"
        print("   [PASS] Fingerprint generation and verification")
        
        # 8. SessionManager
        print("\n8. SessionManager")
        session_mgr = SessionManager()
        session_id = session_mgr.create_session(peer_id="entity-b")
        print(f"   Created session: {session_id}")
        
        seq, valid = session_mgr.get_next_sequence_num(session_id)
        print(f"   Sequence 1: {seq} (valid: {valid})")
        assert seq == 1, "First sequence should be 1"
        
        seq2, valid2 = session_mgr.get_next_sequence_num(session_id)
        print(f"   Sequence 2: {seq2} (valid: {valid2})")
        assert seq2 == 2, "Second sequence should be 2"
        
        # Validate specific sequence
        valid_seq, error = session_mgr.validate_sequence(session_id, 3)
        print(f"   Validate sequence 3: {valid_seq}")
        assert valid_seq, f"Sequence validation failed: {error}"
        
        # Check not expired
        assert not session_mgr.is_expired(session_id), "Session should not be expired"
        print("   [PASS] Session management working")
        
        # 9. E2EEncryption
        print("\n9. E2EEncryption (Ed25519->X25519 + HKDF + AES-256-GCM)")
        e2e = E2EEncryption()
        
        # Test Ed25519 to X25519 conversion
        x25519_priv = e2e.ed25519_to_x25519_private(kp_a.private_key)
        x25519_pub_a = e2e.ed25519_to_x25519_public(kp_a.public_key)
        x25519_pub_b = e2e.ed25519_to_x25519_public(kp_b.public_key)
        print(f"   Converted X25519 public A: {x25519_pub_a.hex()[:32]}...")
        print(f"   Converted X25519 public B: {x25519_pub_b.hex()[:32]}...")
        
        # Derive shared key
        shared_key_ab = e2e.derive_shared_key(
            kp_a.private_key, kp_b.public_key, "entity-b"
        )
        shared_key_ba = e2e.derive_shared_key(
            kp_b.private_key, kp_a.public_key, "entity-a"
        )
        assert shared_key_ab == shared_key_ba, "Shared keys should match"
        print(f"   Shared key derived: {shared_key_ab.hex()[:32]}...")
        
        # Encrypt/decrypt
        test_msg = {"secret": "E2E encrypted data", "timestamp": datetime.now(timezone.utc).isoformat()}
        encrypted_v1 = e2e.encrypt_message(
            test_msg,
            kp_a.private_key,
            kp_b.public_key,
            "entity-b"
        )
        print(f"   Encrypted: {encrypted_v1['ciphertext'][:50]}...")
        
        decrypted_v1 = e2e.decrypt_message(
            encrypted_v1,
            kp_b.private_key,
            kp_a.public_key,
            "entity-a"
        )
        assert decrypted_v1 == test_msg, "E2E decryption mismatch"
        print("   [PASS] E2E encryption/decryption successful")
        
        # 10. SecureMessageV1
        print("\n10. SecureMessageV1 (v1.0 Format)")
        msg_v1 = SecureMessageV1(
            msg_type="chat",
            sender_id="entity-a",
            recipient_id="entity-b",
            payload={"text": "Hello v1.0!"},
            session_id=session_id,
            sequence_num=1
        )
        msg_v1.sign(signer)
        print(f"   Message v1.0 created with recipient_id: {msg_v1.recipient_id}")
        print(f"   Session ID: {msg_v1.session_id}")
        print(f"   Sequence: {msg_v1.sequence_num}")
        print(f"   Signature: {msg_v1.signature[:50]}...")
        
        # Verify
        msg_v1_dict = msg_v1.to_dict()
        assert msg_v1_dict["recipient_id"] == "entity-b", "recipient_id missing"
        assert msg_v1_dict["session_id"] == session_id, "session_id missing"
        assert msg_v1_dict["sequence_num"] == 1, "sequence_num missing"
        print("   [PASS] v1.0 message format correct")
        
        # 11. Chunking
        print("\n11. Message Chunking")
        large_msg = SecureMessageV1(
            msg_type="large_data",
            sender_id="entity-a",
            recipient_id="entity-b",
            payload={"chunk": "part 1"}
        )
        chunk_msg = large_msg.create_chunk(
            chunk_index=0,
            total_chunks=3,
            message_id="msg-123",
            chunk_payload={"chunk": "part 1"}
        )
        print(f"   Chunk message: index={chunk_msg.chunk_info.chunk_index}, total={chunk_msg.chunk_info.total_chunks}")
        print(f"   Message ID: {chunk_msg.chunk_info.message_id}")
        assert chunk_msg.is_chunk(), "Should be recognized as chunk"
        print("   [PASS] Chunking functionality working")
        
        # 12. From dict and back
        print("\n12. Serialization (to_dict/from_dict)")
        msg_v1_restored = SecureMessageV1.from_dict(msg_v1_dict)
        assert msg_v1_restored.version == "1.0", "Version mismatch"
        assert msg_v1_restored.recipient_id == msg_v1.recipient_id, "Recipient mismatch"
        assert msg_v1_restored.signature == msg_v1.signature, "Signature mismatch"
        print("   [PASS] Serialization round-trip successful")
        
        print("\n" + "=" * 60)
        print("All v1.0 tests passed!")
        print("=" * 60)
        
    else:
        print("PyNaCl not installed. Skipping tests.")


# =============================================================================
# WalletManager - Unified wallet persistence (migrated from crypto_utils.py)
# =============================================================================

# Try to import cryptography library for WalletManager
try:
    from cryptography.hazmat.primitives import serialization, hashes
    from cryptography.hazmat.primitives.asymmetric.ed25519 import (
        Ed25519PrivateKey, Ed25519PublicKey,
    )
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
    from cryptography.exceptions import InvalidSignature
    CRYPTOGRAPHY_AVAILABLE = True
except ImportError:
    CRYPTOGRAPHY_AVAILABLE = False


class WalletManager:
    """
    
    Ed25519AES-256-GCM
    PBKDF2
    
    Note: cryptographycrypto.py
    """
    
    # 
    WALLET_VERSION = 1
    PBKDF2_ITERATIONS = 600000  # OWASP
    SALT_SIZE_BYTES = 32  # 256-bit salt
    NONCE_SIZE_BYTES = 12  # 96-bit nonce for AES-GCM
    AES_KEY_SIZE_BYTES = 32  # 256-bit key
    
    def __init__(self, wallet_path: Optional[str] = None):
        """WalletManager
        
        Args:
            wallet_path:  ~/.peer_service/wallet.json
        """
        if not CRYPTOGRAPHY_AVAILABLE:
            raise ImportError("cryptography library is required for WalletManager")
        
        if wallet_path is None:
            wallet_path = os.path.expanduser("~/.peer_service/wallet.json")
        
        self.wallet_path = wallet_path
        self._wallet_dir = os.path.dirname(wallet_path)
        self._private_key_hex: Optional[str] = None
        self._public_key_hex: Optional[str] = None
    
    def wallet_exists(self) -> bool:
        """
        
        Returns:
            True
        """
        return os.path.exists(self.wallet_path)
    
    def _ensure_wallet_directory(self) -> None:
        """"""
        if self._wallet_dir and not os.path.exists(self._wallet_dir):
            os.makedirs(self._wallet_dir, mode=0o700)  # 
    
    def _derive_key_from_password(self, password: str, salt: bytes) -> bytes:
        """PBKDF2
        
        Args:
            password: 
            salt: 
            
        Returns:
            32
        """
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=self.AES_KEY_SIZE_BYTES,
            salt=salt,
            iterations=self.PBKDF2_ITERATIONS,
        )
        return kdf.derive(password.encode("utf-8"))
    
    def _generate_keypair_cryptography(self) -> Tuple[str, str]:
        """cryptographyEd25519
        
        Returns:
            (private_key_hex, public_key_hex)
        """
        private_key = Ed25519PrivateKey.generate()
        public_key = private_key.public_key()
        
        private_bytes = private_key.private_bytes(
            encoding=serialization.Encoding.Raw,
            format=serialization.PrivateFormat.Raw,
            encryption_algorithm=serialization.NoEncryption()
        )
        public_bytes = public_key.public_bytes(
            encoding=serialization.Encoding.Raw,
            format=serialization.PublicFormat.Raw
        )
        
        return private_bytes.hex(), public_bytes.hex()
    
    def create_wallet(self, password: str) -> Tuple[str, str]:
        """
        
        Args:
            password: 
            
        Returns:
            (private_key_hex, public_key_hex)
            
        Raises:
            ValueError: 
            FileExistsError: 
        """
        if not password:
            raise ValueError("Password cannot be empty")
        
        if self.wallet_exists():
            raise FileExistsError(f"Wallet already exists at {self.wallet_path}")
        
        # 
        private_key_hex, public_key_hex = self._generate_keypair_cryptography()
        
        # nonce
        salt = secrets.token_bytes(self.SALT_SIZE_BYTES)
        nonce = secrets.token_bytes(self.NONCE_SIZE_BYTES)
        
        # 
        encryption_key = self._derive_key_from_password(password, salt)
        
        # AES-256-GCM
        private_key_bytes = bytes.fromhex(private_key_hex)
        aesgcm = AESGCM(encryption_key)
        ciphertext = aesgcm.encrypt(nonce, private_key_bytes, None)
        
        # 
        wallet_data = {
            "version": self.WALLET_VERSION,
            "public_key": public_key_hex,
            "encrypted_private_key": base64.b64encode(ciphertext).decode("ascii"),
            "salt": base64.b64encode(salt).decode("ascii"),
            "nonce": base64.b64encode(nonce).decode("ascii"),
        }
        
        # 
        self._ensure_wallet_directory()
        with open(self.wallet_path, "w", encoding="utf-8") as f:
            json.dump(wallet_data, f, indent=2)
        
        # 
        os.chmod(self.wallet_path, 0o600)
        
        # 
        self._private_key_hex = private_key_hex
        self._public_key_hex = public_key_hex
        
        return private_key_hex, public_key_hex
    
    def load_wallet(self, password: str) -> Tuple[str, str]:
        """
        
        Args:
            password: 
            
        Returns:
            (private_key_hex, public_key_hex)
            
        Raises:
            FileNotFoundError: 
            ValueError: 
        """
        if not self.wallet_exists():
            raise FileNotFoundError(f"Wallet not found at {self.wallet_path}")
        
        # 
        with open(self.wallet_path, "r", encoding="utf-8") as f:
            wallet_data = json.load(f)
        
        # 
        version = wallet_data.get("version")
        if version != self.WALLET_VERSION:
            raise ValueError(f"Unsupported wallet version: {version}")
        
        # 
        try:
            ciphertext = base64.b64decode(wallet_data["encrypted_private_key"])
            salt = base64.b64decode(wallet_data["salt"])
            nonce = base64.b64decode(wallet_data["nonce"])
            public_key_hex = wallet_data["public_key"]
        except (KeyError, base64.binascii.Error) as e:
            raise ValueError(f"Invalid wallet format: {e}")
        
        # 
        encryption_key = self._derive_key_from_password(password, salt)
        
        # 
        try:
            aesgcm = AESGCM(encryption_key)
            private_key_bytes = aesgcm.decrypt(nonce, ciphertext, None)
        except Exception as e:
            raise ValueError("Invalid password or corrupted wallet data") from e
        
        private_key_hex = private_key_bytes.hex()
        
        # 
        try:
            private_key = Ed25519PrivateKey.from_private_bytes(private_key_bytes)
            derived_public_key = private_key.public_key()
            derived_public_bytes = derived_public_key.public_bytes(
                encoding=serialization.Encoding.Raw,
                format=serialization.PublicFormat.Raw
            )
            if derived_public_bytes.hex() != public_key_hex:
                raise ValueError("Public key mismatch: wallet may be corrupted")
        except Exception as e:
            raise ValueError(f"Key validation failed: {e}")
        
        # 
        self._private_key_hex = private_key_hex
        self._public_key_hex = public_key_hex
        
        return private_key_hex, public_key_hex
    
    def get_keys(self) -> Tuple[Optional[str], Optional[str]]:
        """
        
        Returns:
            (private_key_hex, public_key_hex)None
        """
        return self._private_key_hex, self._public_key_hex
    
    def delete_wallet(self) -> None:
        """
        
        Raises:
            FileNotFoundError: 
        """
        if not self.wallet_exists():
            raise FileNotFoundError(f"Wallet not found at {self.wallet_path}")
        
        os.remove(self.wallet_path)
        self._private_key_hex = None
        self._public_key_hex = None
